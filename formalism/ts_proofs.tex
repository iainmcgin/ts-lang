\documentclass{article}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{listings}
\usepackage{proof}
\usepackage{supertabular}
\usepackage{geometry}
\usepackage{color}
\usepackage{proof}
\usepackage{theorem}

\newtheorem{lem}{Lemma}
\newtheorem{thm}{Theorem}
\newtheorem{defn}{Definition}
\newtheorem{cor}{Corollary}

\newcommand{\Tr}{\mathit{Tr}}
\newcommand{\secref}[1]{Section \ref{#1}}
\newcommand{\figref}[1]{Figure \ref{#1}}
\newcommand{\lstref}[1]{Listing \ref{#1}}
\newcommand{\appref}[1]{Appendix \ref{#1}}
\newcommand{\lemref}[1]{Lemma \ref{#1}}

\newcommand{\rlett}{\textsc{r\_let\_term} }
\newcommand{\rletv}{\textsc{r\_let\_value} }
\newcommand{\rupdt}{\textsc{r\_update\_term} }
\newcommand{\rupdv}{\textsc{r\_update\_value} }
\newcommand{\rseqlt}{\textsc{r\_seq\_left\_term} }
\newcommand{\rseqlv}{\textsc{r\_seq\_left\_value} }
\newcommand{\rfunc}{\textsc{r\_fun\_call} }
\newcommand{\rmethc}{\textsc{r\_meth\_call} }
\newcommand{\rifexpr}{\textsc{r\_if\_term} }
\newcommand{\riftrue}{\textsc{r\_if\_true} }
\newcommand{\riffalse}{\textsc{r\_if\_false} }

\newcommand{\tunit}{\textsc{t\_unit} }
\newcommand{\ttrue}{\textsc{t\_true} }
\newcommand{\tfalse}{\textsc{t\_false} }
\newcommand{\tobj}{\textsc{t\_object} }
\newcommand{\tfundef}{\textsc{t\_fun\_def} }
\newcommand{\tlet}{\textsc{t\_let} }
\newcommand{\tupd}{\textsc{t\_update} }
\newcommand{\tif}{\textsc{t\_if} }
\newcommand{\tseq}{\textsc{t\_seq} }
\newcommand{\tfunc}{\textsc{t\_fun\_call} }
\newcommand{\tmethc}{\textsc{t\_meth\_call} }
\newcommand{\tdrop}{\textsc{t\_drop} }
\newcommand{\tsub}{\textsc{t\_sub} }
\newcommand{\tsubctx}{\textsc{t\_sub\_ctx} }

\newcommand{\typerule}[4]{#1 \triangleright #2 : #3 \triangleleft #4}
\newcommand{\oprule}[4]{#1 \mid #2\;\longrightarrow\;#3 \mid #4}
\newcommand{\inferrule}[4]{\llbracket #1 \triangleright #2 : #3 \triangleleft #4 \rrbracket}
\newcommand{\inferlhs}[1]{\llbracket \gamma \triangleright #1 : \alpha \triangleleft \gamma' \rrbracket}
\newcommand{\subst}[3]{#3 \{\overline{^{#1}/_{#2}}\}}
\newcommand{\substxy}[1]{\subst{x_i}{y_i}{#1}}
\newcommand{\unitv}{\mathtt{unit}}
\newcommand{\unitt}{\mathbf{Unit}}
\newcommand{\truev}{\mathtt{true}}
\newcommand{\falsev}{\mathtt{false}}
\newcommand{\boolt}{\mathbf{Bool}}
\newcommand{\funv}[4]{\lambda(\overline{#1 : #2 \gg #3}).#4}
\newcommand{\funt}[3]{(\overline{(#1 \gg #2) \rightarrow #3}}
\newcommand{\lett}[3]{\mathtt{let}\:#1\:\mathtt{=}\:#2\:\mathtt{in}\:#3}
\newcommand{\upt}[2]{#1\:\mathtt{:=}\:#2}
\newcommand{\ift}[3]{\mathtt{if} \; #1 \; \mathtt{then} \; #2 \; \mathtt{else} \; #3}
\newcommand{\cand}{\:\wedge\:}
\newcommand{\free}[1]{\mathbf{free}\:#1}
\newcommand{\fresh}[1]{\mathbf{fresh}\:#1}

\newcommand{\qed}{$\blacksquare$}

\newenvironment{proof}{\vspace{1ex}\noindent{\bf Proof}\hspace{0.5em}}
  {\hfill\qed\vspace{1ex}}

\input{ts_defns}

\begin{document}

\title{TS1 - A simple linear calculus for typestate inference}
\author{Iain McGinniss}

\section{Grammar}

\ottgrammartabular{
\ottt\ottinterrule
\ottv\ottinterrule
\otto\ottinterrule
\ottsv\ottinterrule
\ottT\ottinterrule
\ottO\ottinterrule
\ottst\ottinterrule
}

\section{Operational Semantics}

\ottgrammartabular{
\ottmu\ottinterrule
}

\ottdefnvalidstore

\ottdefnreduce

\section{Type rules}
\label{sec:typerules}

\ottgrammartabular{
\ottG\ottinterrule
\ottT\ottinterrule
}

\ottdefnvalidgamma

\ottdefnstoretype

\ottdefnmethtype

\ottdefnsubtype

\ottdefntype

\section{Soundness proofs}

\subsection{Supporting lemmas}

\begin{lem}
\label{lem:valuectx}
If $v$ is a value and $\typerule{\Gamma}{v}{T}{\Gamma'}$, then $\Gamma = \Gamma'$.
\end{lem}
\begin{proof}
Directly from the typing judgements. $v$ is either {\tt unit}, {\tt true},
{\tt false}, a function literal or an object literal.
Correspondingly, by rules \tunit,
\ttrue, \tfalse, 
\tfundef and \tobj, $\Gamma = \Gamma'$.
\end{proof}

\begin{lem}[Weakening]
If $\typerule{\Gamma}{t}{T}{\Gamma'}$,
then for all $\Gamma''$ such that $dom(\Gamma) \cap dom(\Gamma'') = \emptyset$,
$t$ can also be typed such that
$\typerule{\Gamma, \Gamma''}{t}{T}{\Gamma', \Gamma''}$.
\end{lem}
\begin{proof}
by induction on the structure of $t$.

If $t$ is some value $v$, it follows by \lemref{lem:valuectx} that 
$\Gamma = \Gamma'$ and that the typing derivation will still be valid as long
as the input and output contexts are identical. Therefore,
$\typerule{\Gamma , \Gamma''}{v}{T}{\Gamma', \Gamma''}$.

If $t$ is not a value, then it is of one of the following forms:

\begin{itemize}
\item $t = \lett{x}{t'}{t''}$. It follows from rule \tlet that
there exists $\Gamma_1, \Gamma_2, T', T''$ such that
$\typerule{\Gamma}{t'}{T'}{\Gamma_1}$ and
$\typerule{\Gamma_1, x : T'}{t''}{T}{\Gamma', x : T''}$.
By \tlet we have that $dom(\Gamma') = dom(\Gamma)$.
By induction, $t'$ can be typed such
that $\typerule{\Gamma,\Gamma''}{t'}{T'}{\Gamma_1,\Gamma''}$,
and $t''$ can be typed such that
$\typerule{\Gamma_1, \Gamma'', x : T'}{t''}{T}{\Gamma', \Gamma'', x : T''}$,
as we can assume by Barendregt's convention that $x$ can be made distinct from
any variable names in $\Gamma''$ by relabeling $x$.
Therefore,
$\typerule{\Gamma, \Gamma''}{\lett{x}{t'}{t''}}{T}{\Gamma', \Gamma''}$.

\item $t = \upt{x}{t'}$. It follows from rule \tupd that
there exists $\Gamma_1, \Gamma_2, T_1, T'$ such that
$\Gamma = \Gamma_1, x : T_1$ and that
$\Gamma' = \Gamma_2, x : T'$, with
$\typerule{\Gamma_1}{t'}{T'}{\Gamma_2}$.
As $\Gamma$ and $\Gamma''$ are disjoint and by \tupd, 
$dom(\Gamma_2) \subseteq dom(\Gamma)$, $t'$ can be typed such that
$\typerule{\Gamma, \Gamma''}{t'}{T_2}{\Gamma_2, \Gamma''}$.
Therefore $\typerule{\Gamma, \Gamma''}{\upt{x}{t'}}{T}{\Gamma', \Gamma''}$.

\item $t = x ( \overline{x_i} )$. It follows from the rule \tfunc that
there exists a $\Gamma_1$ such that 
$\Gamma = \Gamma_1, x : (\overline{U_i \gg T_i'}) \rightarrow T, \overline{x_i : T_i}$
with $T_i <: U_i$ for each $i$
and that 
$\Gamma' = \Gamma_1, x : (\overline{U_i \gg T_i'}) \rightarrow T, \overline{x_i : T_i'}$.
As $\Gamma_1$ can be arbitrary in the rule \tfunc, it follows that we
can extend the input and output contexts such that
$\typerule{\Gamma, \Gamma''}{x ( \overline{x_i} )}{T}{\Gamma', \Gamma''}$.

\item $t = x.m$. It follows from the rule \tmethc that there exists
a $\Gamma_1$ such that $\Gamma = \Gamma_1, x : O@S$ and that $\Gamma' = \Gamma_1, x : O@S'$.
As $\Gamma_1$ can be arbitrary in rule \tmethc, it follows that we can
extend the input and out contexts such that
$\typerule{\Gamma, \Gamma''}{x.m}{T}{\Gamma', \Gamma''}$.

\item $t = t' ; t''$. It follows from the rule \tseq that there exists
$\Gamma_1$ and $T'$ such that $\typerule{\Gamma}{t'}{T'}{\Gamma_1}$
and $\typerule{\Gamma_1}{t''}{T}{\Gamma'}$. By induction
$\typerule{\Gamma, \Gamma''}{t'}{T'}{\Gamma_1, \Gamma''}$
as $dom(\Gamma_1) \subseteq dom(\Gamma)$ and therefore
$\Gamma_1$ and $\Gamma''$ are disjoint.
Similarly, as $dom(\Gamma_1) = dom(\Gamma')$, by induction
$\typerule{\Gamma_1, \Gamma''}{t''}{T}{\Gamma', \Gamma''}$.
Therefore $\typerule{\Gamma, \Gamma''}{t'}{T'}{\Gamma_1, \Gamma''}$.

\item $t = \ift{t_c}{t_t}{t_f}$. It follows from rule \tif that there
exists $\Gamma_1$, $\Gamma_2$, $\Gamma_3$, $T_t$ and $T_f$ such that
$\typerule{\Gamma}{t_c}{\boolt}{\Gamma_1}$ and that
$\typerule{\Gamma_1}{t_t}{T_t}{\Gamma_2}$ and that
$\typerule{\Gamma_1}{t_f}{T_f}{\Gamma_3}$ with
$\Gamma' = \Gamma_2 \sqcup \Gamma_3$ and $T = T_t \sqcup T_f$.
By induction each of $\Gamma_1$, $\Gamma_2$ and $\Gamma_3$ can
be extended by $\Gamma''$ in the typing judgements for $t_c$,
$t_t$ and $t_f$. As $\Gamma'' \sqcup \Gamma'' = \Gamma''$, it
follows that $(\Gamma_2, \Gamma'') \sqcup (\Gamma_3, \Gamma'') = 
\Gamma_2 \sqcup \Gamma_3, \Gamma''$ and therefore $t$ can be
typed such that $\typerule{\Gamma, \Gamma''}{t}{T}{\Gamma', \Gamma''}$.

\end{itemize}

\end{proof}

\begin{lem}[Substitution]
If $\typerule{\Gamma}{t}{T}{\Gamma'}$, then
$\typerule
{\subst{x_i}{y_i}{\Gamma}}
{\subst{x_i}{y_i}{t}}
{T}
{\subst{x_i}{y_i}{\Gamma'}}$
where each $x_i$ and $y_i$ is distinct, and $\overline{x_i} \cap \overline{y_i} = \emptyset$.
\end{lem}
\begin{proof}
By induction on the structure of $t$.

If $t$ is some value $v$, then $\Gamma = \Gamma'$, therefore
$\subst{x_i}{y_i}{\Gamma} = \subst{x_i}{y_i}{\Gamma'}$
and substitution has no effect on the value, which has no specific requirements
of either $\Gamma$ or $\Gamma'$ other than that they are equal.
Therefore, $\typerule{\subst{x_i}{y_i}{\Gamma}}{\subst{x_i}{y_i}{v}}{T}{\subst{x_i}{y_i}{\Gamma'}}$.

If $t$ is a term, then it is of one of the following forms:

\begin{itemize}
\item $t = \lett{x}{t''}{t'}$. 
Substitution is defined on this term such that
$\subst{x_i}{y_i}{t} \equiv 
\lett{x}{( \subst{x_i}{y_i}{t''} )}{(\{ \overline{x_j / y_j} \}t')}$
, where $\overline{y_j} = \overline{y_i} / \{ x \}$.

By rule \tlet, it follows
that there exists $T', T'', \Gamma_1$ such that
$\typerule{\Gamma}{t''}{T''}{\Gamma_1}$ and that
$\typerule{\Gamma_1, x : T''}{t''}{T}{\Gamma', x : T'}$.
Additionally, $x \notin dom(\Gamma)$.

By induction, $t''$ can be substituted such that 
$\typerule
{\subst{x_i}{y_i}{\Gamma}}
{\subst{x_i}{y_i}{t''}}
{\subst{x_i}{y_i}{\Gamma_1}}
$.
Additionally, $t'$ can be substituted such that
$(\subst{x_j}{y_j}{\Gamma_1}) , x : T'' \triangleright \subst{x_j}{y_j}{t''} \triangleleft \{ (\overline{x_j / y_j} \} \Gamma') , x : T'$ as it is guaranteed that $x \notin \overline{y_j}$.
As $dom(\Gamma') = dom(\Gamma)$, and that $x \notin dom(\Gamma)$, it follows that $\subst{x_i}{y_i}{\Gamma_1} = (\subst{x_j}{y_j}{\Gamma_1})$ and
that $\overline{x_i / y_i} \} \Gamma' = \overline{x_j / y_j} \} \Gamma'$.

Therefore, the requirements of \tlet are satisfied such that
$\typerule{\subst{x_i}{y_i}{\Gamma}}{\subst{x_i}{y_i}{t}}{T}{\subst{x_i}{y_i}{\Gamma'}}$.

\item $t = \upt{x}{t'}$. 
Substitution is defined on this term such that
$\{ \overline{x_i / y_i} \} ( x\::=\:t' ) \equiv y\::=\: \subst{x_i}{y_i}{t'}$
where $y = x$ if $x \notin \overline{y_i}$ and $y = x_j$ if
$x = y_j$ for some $y_j \in \overline{y_i}$.

By rule \tupd, there exists
$T', T'' \Gamma_1, \Gamma_2$ such that
$\Gamma = \Gamma_1, x : T''$ and $\Gamma' = \Gamma_2, x : T'$ with
$\typerule{\Gamma_1}{t'}{T''}{\Gamma_2}$. 

By induction,
substitution can be performed on $t'$ such that
$\typerule{\subst{x_i}{y_i}{\Gamma_1}}{\subst{x_i}{y_i}{t'}}{T''}{\subst{x_i}{y_i}{\Gamma_2}}$. 

\begin{itemize}
\item If $x \in \overline{y_i}$,
$\subst{x_i}{y_i}{\Gamma_1}, x : T'' \equiv (\subst{x_i}{y_i}{\Gamma_1}), x_j : T''$
and
$\subst{x_i}{y_i}{\Gamma_2}, x : T' \equiv (\subst{x_i}{y_i}{\Gamma_2}), x_j : T'$.
Therefore, $t$ can by typed by \tupd after the substitution.
\item If $x \notin \overline{y_i}$, then
$\subst{x_i}{y_i}{\Gamma_1}, x : T'' \equiv (\subst{x_i}{y_i}{\Gamma_1}), x : T''$
and
$\subst{x_i}{y_i}{\Gamma_2}, x : T' \equiv (\subst{x_i}{y_i}{\Gamma_2}), x : T'$.
Therefore, $t$ can be typed by \tupd after the substitution.
\end{itemize}

\item $t = t_l ; t_r$.
Substitution is defined on this term such that
$\{ \overline{x_i / y_i} \} ( t_l ; t_r ) \equiv \subst{x_i}{y_i}{t_l} ; \subst{x_i}{y_i}{t_r}$.

By rule \tseq, there exists $\Gamma'', T'$ such that
$\typerule{\Gamma}{t_l}{T'}{\Gamma''}$ and
$\typerule{\Gamma''}{t_r}{T}{\Gamma'}$. By induction,
$\typerule{\subst{x_i}{y_i}{\Gamma}}{\subst{x_i}{y_i}{t_l}}{T'}{\subst{x_i}{y_i}{\Gamma''}}$ and
$\typerule{\subst{x_i}{y_i}{\Gamma''}}{\subst{x_i}{y_i}{t_r}}{T}{\subst{x_i}{y_i}{\Gamma'}}$.
Therefore, $t$ can by typed \tseq after the substitution.

\item $t = x_0 ( \overline{x_k} )$.
Substition is defined on this term such that
$\subst{x_i}{y_i}{x_0} ( \overline{x_k} ) \equiv y_0 ( \overline{y_k} )$
where for each $x \in \{ x_0, \overline{x_k} \}$,
$x = y_j \implies y = x_j$, otherwise $y$ is the original value.

For each substitution that occurs in the term, the variable must exist in
both the input and output contexts by rule \tfunc, and will be substituted
for the same name. Therefore, $t$ can be typed by \tfunc after the
substitution.

\item $t = x.m$.
Substition is defined on this term such that
$\subst{x_i}{y_i}{x.m} \equiv y.m$
where $y = x_j$ if $x = y_j$ for some $y_j \in \overline{y_i}$.
Otherwise, $y = x$.

Rule \tmethc requires that $x$ exist in both $\Gamma$ and $\Gamma'$ and
therefore any substitution of x in the term will be matched with the
same substitution in the contexts. Therefore, $t$ can be typed by
\tmethc after the substitution.

\item $t = \ift{t_c}{t_t}{t_f}$. Substitution is defined on this term such
that \\
$\subst{x_i}{y_i}{(\ift{t_c}{t_t}{t_f})} \equiv 
\ift{\substxy{t_c}}{\substxy{t_t}}{\substxy{t_f}}$.
By rule \tif there exists $\Gamma_1$, $\Gamma_2$, $\Gamma_3$, $T_t$, $T_f$
such that
$\typerule{\Gamma}{t_c}{\boolt}{\Gamma_1}$ and that
$\typerule{\Gamma_1}{t_t}{T_t}{\Gamma_2}$ and that
$\typerule{\Gamma_1}{t_f}{T_f}{\Gamma_3}$ where
$\Gamma' = \Gamma_2 \sqcup \Gamma_3$ and $T = T_t \sqcup T_f$. By induction
substitution can be performed on $t_c$, $t_t$ and $t_f$ such that
$\typerule{\substxy{\Gamma}}{\substxy{t_c}}{\boolt}{\substxy{\Gamma_1}}$ and that
$\typerule{\substxy{\Gamma_1}}{\substxy{t_t}}{T_t}{\substxy{\Gamma_2}}$ and
$\typerule{\substxy{\Gamma_1}}{\substxy{t_f}}{T_f}{\substxy{\Gamma_3}}$.
By the definition of substitution on contexts, 
$\substxy{\Gamma_2} \sqcup \substxy{\Gamma_3} = \substxy{\Gamma'}$. Therefore,
by rule \tif, 
$\typerule{\substxy{\Gamma}}{\substxy{\ift{t_c}{t_t}{t_f}}}{T}{\substxy{\Gamma'}}$.
\end{itemize}
\end{proof}

\subsection{Progress and Preservation}

\begin{thm}[Progress and Preservation]
Given a term $t$ such that $\typerule{\Gamma}{t}{T}{\Gamma'}$
with a store $\mu$ such that $\Gamma \vdash \mu$, either $t$ is a value or 
there exist $t'$ and $\mu'$ such that
$\oprule{t}{\mu}{t'}{\mu'}$, with some $\Gamma''$ such that
$\Gamma'' \vdash \mu'$ and $\typerule{\Gamma''}{t'}{T}{\Gamma'}$.
\end{thm}

\begin{proof}
by induction on the structure of $t$. Assume $t$ is not a value. It is
therefore of one of the following forms:

\begin{itemize}
\item $t = \lett{x}{t''}{t'}$. 
It follows by rule \tlet that there exist $\Gamma_1, T', T''$
such that
$\typerule{\Gamma}{t''}{T'}{\Gamma_1}$ and that
$\typerule{\Gamma_1, x : T'}{t'}{T}{\Gamma', x : T''}$. There are two
possibilities:

	\begin{itemize}
	\item If $t''$ is some value $v$, then by \lemref{lem:valuectx} 
	we have that $\Gamma = \Gamma_1$ and reduction can occur
	by \rletv, such that 
	$\oprule{\lett{x}{v}{t'}}{\mu}{t'}{\mu [ x \mapsto v ]}$.
	Let $\mu' = \mu [ x \mapsto v ]$. Let $\Gamma'' = \Gamma, x : T'$.
	It follows that that $\Gamma'' \vdash \mu'$, with
	$\typerule{\Gamma''}{t'}{T}{\Gamma', x : T'}$.
	The requirements of rule \tdrop are satisfied by this, therefore we can 
	type $t'$ such that $\typerule{\Gamma''}{t'}{T}{\Gamma'}$.

	\item If $t''$ is a term, 
	by induction we have that $\oprule{t''}{\mu}{t'''}{\mu'}$, with
	$\Gamma'' \vdash \mu'$ and $\typerule{\Gamma''}{t'''}{T'}{\Gamma_1}$.
	This satisfies the requirements of \rlett, meaning $t$ itself can reduce
	such that $\oprule{\lett{x}{t''}{t'}}{\mu}{\lett{x}{t'''}{t'}}{\mu'}$.
	Additionally, the conditions of \tlet are satisfied such that
	$\typerule{\Gamma''}{\lett{x}{t'''}{t'}}{T}{\Gamma'}$.

	\end{itemize}

\item $t = \upt{x}{t'}$. It follows from rule \tupd that $\Gamma = \Gamma_1, x : T$ 
and $\Gamma' = \Gamma_2, x : T'$ with $\typerule{\Gamma_1}{t'}{T'}{\Gamma_2}$,
and $\Gamma_1, x : T \vdash \mu_1, x \mapsto v$.

	\begin{itemize}
	\item If $t'$ is some value $v'$, 
	then reduction can occur by \\
	\rupdv, such that 
	$x := v' \mid \mu_1, x \mapsto v \longrightarrow \unitv \mid \mu_1 , x \mapsto v'$.
	Let $\mu' = \mu_1, x \mapsto v'$. Let $\Gamma'' = \Gamma, x : T'$.
	It follows that $\Gamma'' \vdash \mu'$. Additionally, as $e$ was a value,
	$\Gamma = \Gamma_2$ (by \lemref{lem:valuectx}), consequently 
	$\Gamma'' = \Gamma'$ and therefore
	$\typerule{\Gamma''}{\unitv}{\unitt}{\Gamma'}$ by rule
	\tunit.

	\item If $t'$ is a term, 
	by induction we have that $\oprule{t'}{\mu_1}{t''}{\mu_2}$
	with some $\Gamma_3$ such that $\Gamma_3 \vdash \mu_2$ and
	$\typerule{\Gamma_3}{t''}{T'}{\Gamma_2}$.
	This satisfies the requirements of \rupdt, meaning $t$ itself can reduced
	such that 
	$\oprule{x := t'}{\mu_1, x \mapsto v}{x := t''}{\mu_2, x \mapsto v}$.
	Let $\mu' = \mu_2, x \mapsto v$. Let $\Gamma''$ = $\Gamma_3, x : T$.
	It follows that $\Gamma'' \vdash \mu'$. 
	Additionally, the requirements of \tupd are satisfied such that
	$\typerule{\Gamma''}{x := t''}{\unitt}{\Gamma'}$.
	\end{itemize}

\item $t = t_l ; t_r$. It follows by rule
\tseq that $\typerule{\Gamma}{t_l}{T_l}{\Gamma_{mid}}$ and
$\typerule{\Gamma_{mid}}{t_r}{T}{\Gamma'}$.

	\begin{itemize}
	\item If $t_l$ is some value $v$, then
	reduction can occur by \\ 
	\rseqlv such that
	$t_l; t_r \mid \mu \longrightarrow t_r \mu$. By \lemref{lem:valuectx}, 
	$\Gamma'' = \Gamma = \Gamma_{mid}$
	and $\mu' = \mu$, therefore $\Gamma'' \vdash \mu'$ and 
	$\typerule{\Gamma''}{t_r}{T}{\Gamma'}$.

	\item If $t_l$ is a term, by induction $t_l \mid \mu \longrightarrow t_l' \mid \mu'$
	with some $\Gamma'' \vdash \mu'$ and
	$\typerule{\Gamma''}{t_l'}{T_l}{\Gamma_{mid}}$.
	This satisfies the requirements of \rseqlt
	such that $t_l; t_r \mid \mu \longrightarrow t_l'; t_r \mid \mu'$.
	Additionally, the requirements of \tseq are satisfied such that
	$\typerule{\Gamma''}{t_l'; t_r}{T}{\Gamma'}$.

	\end{itemize}

\item $t = x ( \overline{x_i} )$. It follows by rule \tfunc that
$\Gamma = \Gamma_1, x : (\overline{U_i \gg T_i'}) \rightarrow T, \overline{x_i : T_i}$ 
with $\overline{T_i <: U_i}$ and that
$\Gamma' = \Gamma_1, x : (\overline{U_i \gg T_i'}) \rightarrow T, \overline{x_i : T_i'}$.
As $\Gamma \vdash \mu$, we must have $\mu(x) = \lambda(\overline{y_i : U_i \gg T_i'}).t'$
where $\typerule{\overline{y_i : U_i}}{t}{T}{\overline{y_i : T_i'}}$.
Let $t'' = \subst{x_i}{y_i}{t'} $.
The term $t$ can be reduced by \rfunc such that
$x ( \overline{x_i} ) \mid \mu \longrightarrow t'' \mid \mu$.
Let $\mu' = \mu$. Let $\Gamma'' = \Gamma$. By the substitution lemma, 
$\typerule{\overline{x_i : T_i}}{t''}{T}{\overline{x_i : T_i'}}$.
By applying the weakening lemma, we can type $t''$ such that
$\typerule{\Gamma''}{t''}{T}{\Gamma'}$,
with $\Gamma'' \vdash \mu'$.

\item $t = x.m$. It follows by rule \tmethc that
$\Gamma = \Gamma_1, x : O@S$ and that $\Gamma' = \Gamma_1, x : O@S'$. As
$\Gamma \vdash \mu$, we must have $\mu = \mu_1, x \mapsto o@S$ where
$o = [ S \{ m = (v,S') ; ... \} ... ]$ and
$\Gamma_1 \vdash \mu_1$, with 
$\typerule{\emptyset}{v}{T}{\emptyset}$.
Therefore reduction can occur by \rmethc such that
$x.m \mid \mu_1, x \mapsto o@S \longrightarrow v \mid \mu_1, x \mapsto o@S'$.
Let $\mu' = \mu_1, x \mapsto o@S'$. Let $\Gamma'' = \Gamma'$. It follows that
$\Gamma' \vdash \mu'$. Also, as $\Gamma'' = \Gamma'$, it follows by
one of \tunit, \ttrue, \tfalse, \tfundef or \tobj that 
$\typerule{\Gamma''}{v}{T}{\Gamma'}$.

\item $t = \ift{t_c}{t_t}{t_f}$. It follows by rule \tif that there exists
$\Gamma_1$, $\Gamma_2$, $\Gamma_3$, $T_t$ and $T_f$ such that
$\typerule{\Gamma}{t_c}{\boolt}{\Gamma_1}$ and that
$\typerule{\Gamma_1}{t_t}{T_t}{\Gamma_2}$ and that
$\typerule{\Gamma_2}{t_f}{T_f}{\Gamma_3}$ with
$\Gamma' = \Gamma_2 \sqcup \Gamma_3$ and $T = T_t \sqcup T_f$. There are
three possibilities for reduction:

	\begin{itemize}
	\item $t_c = \truev$. By \lemref{lem:valuectx} we have that
	$\Gamma = \Gamma_1$. Reduction can occur by \riftrue such that
	$\oprule{t}{\mu}{t_t}{\mu}$. By \tsub we have that
	$\typerule{\Gamma_1}{t_t}{T}{\Gamma_2}$ as $T_t <: T$. Additionally, for
	all $x \in \Gamma_2$, $\Gamma_2(x) <: \Gamma'(x)$. Therefore by
	repeatedly applying \tsubctx for all $x$, we have that
	$\typerule{\Gamma_1}{t_t}{T}{\Gamma'}$.
	Let $\Gamma'' = \Gamma$, $\mu' = \mu$ and 
	$t' = t_t$. Therefore, $\typerule{\Gamma''}{t'}{T}{\Gamma'}$ with
	$\Gamma'' \vdash \mu'$.

	\item $t_c = \falsev$. By \lemref{lem:valuectx} we have that
	$\Gamma = \Gamma_1$. Reduction can occur by \riffalse such that
	$\oprule{t}{\mu}{t_f}{\mu}$. By \tsub we hhave that
	$\typerule{\Gamma_1}{t_f}{T}{\Gamma_3}$ as $T_f <: T$. Additionally, for
	all $x \in \Gamma_3$, $\Gamma_3(x) <: \Gamma'(x)$. Therefore by
	repeatedly applying \tsubctx for all $x$, we have that
	$\typerule{\Gamma_1}{t_f}{T}{\Gamma'}$. Let $\Gamma'' = \Gamma$,
	$\mu' = \mu$ and $t' = t_f$. Therefore, 
	$\typerule{\Gamma''}{t'}{T}{\Gamma'}$ with $\Gamma'' \vdash \mu'$.

	\item $t_c$ is not a value. By induction, there exists $t_c'$,
	$\mu'$, $\Gamma''$ such that 
	$\oprule{t_c}{\mu}{t_c}{\mu'}$ and 
	$\typerule{\Gamma''}{t_c}{\boolt}{\Gamma_1}$ with $\Gamma'' \vdash \mu'$. 
	Reduction of $t$ can therefore occur by \rifexpr such that
	$\oprule{t}{\mu}{\ift{t_c'}{t_t}{t_f}}{\mu'}$. It follows
	by \tif that $\typerule{\Gamma''}{\ift{t_c'}{t_t}{t_f}}{T}{\Gamma'}$.
	\end{itemize}

\end{itemize}
\end{proof}

\section{Type inference}

Type inference in the style of Pottier, i.e. separate constraint generation
and constraint solving phases to determine the principal typing of a term,
can be defined by observing the requirements imposed by the typing judgements
defined in Section \ref{sec:typerules}.

\ottgrammartabular{
\ottC\ottinterrule
\ottctxc\ottinterrule
\otttyc\ottinterrule
\ottprotoc\ottinterrule
}

\[
\begin{array}{l}

% unit value
\inferlhs{\unitv} \triangleq \alpha = \unitt \cand \gamma = \gamma' 
\\\\

% true value
\inferlhs{\truev} \triangleq \alpha = \boolt \cand \gamma = \gamma' 
\\\\

% false value
\inferlhs{\falsev} \triangleq \alpha = \boolt \cand \gamma = \gamma' 
\\\\

% object value
\inferlhs{[ \overline{S_i \{ \overline{ m_{ij} = (v_{ij}, S_{ij}) } \} }]@S}
\triangleq
\exists \alpha_o, \alpha_s, \overline{\alpha_{ij}}, \overline{\gamma_{ij}} . \\
\alpha = \alpha_o@\alpha_s
\cand
\{ \overline{ S_i \{ \overline{ m_{ij} : \alpha_{ij} >> S_{ij} } \} }\}@S <: \alpha_o@\alpha_s
\cand
\gamma = \gamma'
\cand
\\
\overline{\gamma_{ij} = \emptyset}
\cand
\overline{\inferrule{\gamma_{ij}}{v_{ij}}{\alpha_{ij}}{\gamma_{ij}}}
\\\\

% function value
\inferlhs{\lambda ( \overline{x_i} ) . t} \triangleq
\exists \gamma_r, \gamma_a, \gamma_b, \overline{\alpha_{ai}}, \overline{\alpha_{bi}}, \alpha_r . \\
\alpha = (\overline{\alpha_{ai} \gg \alpha_{bi}}) \rightarrow \alpha_r
\cand
\gamma = \gamma'
\cand
\gamma_r = \emptyset
\cand \\
\gamma_a = \gamma_r, \overline{x_i : \alpha_{ai}}
\cand
\overline{x_i : \alpha_{bi} \in \gamma_b}
\cand
\inferrule{\gamma_a}{t}{\alpha_r}{\gamma_b} 
\\\\

% let binding
\inferlhs{\lett{x}{t'}{t}} \triangleq \exists \gamma_v, \gamma_{b1}, \gamma_{b2}, \alpha' . \\
\gamma_{b1} = \gamma_v, x : \alpha'
\cand
\gamma' = \gamma_{b2} - \{ x \}
\cand \\
\inferrule{\gamma}{t'}{\alpha'}{\gamma_v}
\cand
\inferrule{\gamma_{b1}}{t}{\alpha}{\gamma_{b2}}
\\\\

% update
\inferlhs{x\:\mathtt{:=}\:t'} \triangleq
\exists \gamma_a, \gamma_b, \alpha' . \\
\gamma_a = \gamma - \{ x \}
\cand
\gamma' = \gamma_b, x \mapsto \alpha'
\cand 
\alpha = \unitt
\cand \\
\inferrule{\gamma_a}{t'}{\alpha'}{\gamma_b}
\\\\

% sequence
\inferlhs{t ; t'} \triangleq
\exists \gamma'', \alpha' . \\
\inferrule{\gamma}{t}{\alpha'}{\gamma''}
\cand
\inferrule{\gamma''}{t'}{\alpha}{\gamma'}
\\\\

% function call
\inferlhs{x ( \overline{x_i} )} \triangleq
\exists \overline{\alpha_i}, \overline{\alpha_i'},\overline{\alpha_i''} . \\
x : ( \overline{\alpha_i \gg \alpha_i'} ) \rightarrow \alpha \in \gamma
\cand 
\overline{x_i : \alpha_i'' \in \gamma}
\cand
\\ 
\overline{\alpha_i'' <: \alpha_i}
\cand
\gamma' = \gamma [ \overline{x_i \mapsto \alpha_i'} ]
\\\\

% method call
\inferlhs{x.m} \triangleq
\exists \alpha_o, \alpha_s, \alpha_s' . \\
x : \alpha_o @ \alpha_s \in \gamma
\cand 
m : \alpha \gg \alpha_s' \in \alpha_o @ \alpha_s
\cand  \\
\gamma' = \gamma[ x \mapsto \alpha_o @ \alpha_s' ]
\\\\

% if-then-else
\inferlhs{\ift{t_c}{t_t}{t_f}} \triangleq
\\
\exists \alpha_c, \alpha_t, \alpha_f, \gamma_c, \gamma_t, \gamma_f . \\
\inferrule{\gamma}{t_c}{\alpha_c}{\gamma_c}
\cand
\inferrule{\gamma_c}{t_t}{\alpha_t}{\gamma_t}
\cand 
\\
\inferrule{\gamma_c}{t_f}{\alpha_f}{\gamma_f}
\cand
\alpha_c = \boolt
\cand
\\
\alpha_t <: \alpha
\cand
\alpha_f <: \alpha
\cand
\gamma' = \gamma_t \sqcup \gamma_f
\\\\

\end{array}
\]

\subsection{Context constraint solving}

Constraint solving is performed in phases. In the first phase, the context 
constraints
are normalised using the rules in \figref{fig:contextsolve} --- where the set of 
constraints in the premise exists, they are replaced with those in the 
conclusion. Normalisation means that every context variable will have a single 
defining constraint of form $\gamma = \emptyset$, $\free{\gamma}$ or
$\gamma = \gamma', \overline{x_i : \mathbb{T}_i}$, where $\gamma'$ is
either empty or free. A context $\Gamma$ for type checking can be easily
constructed from constraints in this form, as once the type variable
constraints are solved we can say $\Gamma = \overline{x_i : T_i}$ for
every $\gamma = \gamma', \overline{x_i : \mathbb{T}_i}$ where $T_i$ is the
solved form of $\mathbb{T}_i$.

The context normalisation rules do the following:

\begin{itemize}
\item \textsc{ceq} --- Where $\gamma$ is directly equivalent
to $\gamma'$, which is defined in terms of extension of
$\gamma''$, rewrite the constraints such that
$\gamma$ directly copies the extension of $\gamma''$.
\item \textsc{crem} --- Where $\gamma$ removes a variable $x$ from $\gamma'$,
which is defined in terms of extension of $\gamma''$, rewrite the
constraints such that $\gamma$ copies the extension of $\gamma''$ with
the variable $x$ removed from the extension. There is no need for an
error-producing variant of \textsc{crem}, where the variable $x$ is missing, 
as context removal constraints are always generated in a pair with a context 
extension constraint for let binding.
\item \textsc{cext} --- Where $\gamma$ extends $\gamma'$ with
a variable set $\overline{y_j}$, and $\gamma'$ is defined in terms of extension of
$\gamma''$ with a disjoint set of variables in its extension set, rewrite the
constraints such that $\gamma$'s extension set includes both the $y_j$
definitions and $x_j$ definitions.
\item $\textsc{cext}_2$ --- Where $\gamma$ extends $\gamma'$ with
a new variable $x$, and $\gamma'$ is defined in terms of extension of
some $\gamma''$ and the extension set already contains $x$, this
represents an attempt to redeclare $x$. As such, generate an error
$\mathbf{bound}\:x$, terminating the constraint solving process.
\item \textsc{crep} --- where $\gamma$ replaces the type of some
variable $x$ in $\gamma'$, where $\gamma$ is defined in terms of extension
of $\gamma''$ and $x$ is in the extension set, rewrite the constraints
such that $\gamma$ copies the extension set of $\gamma'$ with $x$
replaced as specified.
\item $\textsc{crep}_2$ --- where $\gamma$ replaces variable $x$ in
$\gamma'$ which is defined in terms of extension of $\gamma''$
which is free and $x$ is not in the extension set, $x$ is a
free variable in the term being processed. To introduce $x$ in such a way that
it will be included in all contexts, $\gamma''$ is redefined in
terms of extension of a new context $\gamma_r$ with variable $x$
in the extension set mapped to a new type variable $\alpha$. Following
this, \textsc{cext} can be applied to $\gamma'$, then \textsc{crep} can
be applied to $\gamma$.
\item $\textsc{crep}_3$ --- where $\gamma$ replaces variable $x$ in
$\gamma'$ which is defined in terms of an empty root $\gamma''$,
and $x$ is not in $\gamma$'s extension set, this indicates the usage
of an unbound variable within a function body. As such, generate an
error $\mathbf{unbound}\:x$ indicating that x is unbound within this
context, terminating the contraint solving process.
\item \textsc{cvar} --- where a variable constraint for $x$ exists
for context variable $\gamma$, which is defined in terms of
extension of $\gamma_r$ which is free, and $x$ is not in the extension
set of $\gamma$, $x$ is a free variable in the term being processed. 
Similar to $\textsc{crep}_2$, redefine $\gamma_r$
in terms of extension of a new root $\gamma_r'$, with $x$ in
the extension set with the observed type $\mathbb{T}$.
\item $\textsc{cvar}_2$ --- where a variable constraint for $x$ exists
for context variable $\gamma$, which is defined in terms of $\gamma'$
which is empty, and $x$ is not in the extension set of $\gamma$, 
$x$ is an unbound variable within a function body.
\end{itemize}

The rules are repeatedly applied to any matching sets of constraints
until no further rewriting is possible, producing either an error
or a set of context constraints which are fully normalised, and
can be converted into contexts for type checking easily.

The way in which the context constraints are generated guarantees
that the dependencies between contexts form a directed acyclic graph. For
this reason, we believe that that the first phase will always terminate,
but this has not yet been proven.

\begin{center}
\begin{tabular}{c}
	\infer[\textsc{ceq}]
	{\gamma = \gamma'', \overline{x_i : \mathbb{T}_i} \cand \gamma' = \gamma'', \overline{x_i : \mathbb{T}_i}}
	{\gamma = \gamma' \cand \gamma' = \gamma'', \overline{x_i : \mathbb{T}_i}}
\\\\
	\infer[\textsc{crem}]
	{
	\gamma = \gamma'', \overline{x_i : \mathbb{T}_i} \cand \gamma' = \gamma'', \overline{x_i : \mathbb{T}_i}, x : \mathbb{T}
	}
	{
	\gamma = \gamma' - \{x\} \cand \gamma' = \gamma'', \overline{x_i : \mathbb{T}_i}, x : \mathbb{T}
	}
\\\\
	\infer[\textsc{cext}]
	{\gamma = \gamma'', \overline{x_i : \mathbb{T}_i}, \overline{y_j : \mathbb{T}_j} \cand \gamma' = \gamma'', \overline{x_i : \mathbb{T}_i}}
	{
		\gamma = \gamma', \overline{y_j : \mathbb{T}_j} \cand \gamma' = \gamma'', \overline{x_i : \mathbb{T}_i}
		& \overline{y_j} \cap \overline{x_i} = \emptyset
	}
\\\\
	\infer[\textsc{cext\_2}]
	{\mathbf{bound}\:x}
	{
		\gamma = \gamma', \overline{y_j : \mathbb{T}_j}, x : \mathbb{T} \cand \gamma' = \gamma'', \overline{x_i : \mathbb{T}_i}
		& x \in \overline{x_i}
	}
\\\\
	\infer[\textsc{crep}]
	{\gamma = \gamma'', \overline{x_i : \mathbb{T}_i}, x : \mathbb{T} \cand
	\gamma' = \gamma'', \overline{x_i : \mathbb{T}_i}, x : \mathbb{T}'}
	{\gamma = \gamma'[x \mapsto \mathbb{T}] \cand
	\gamma' = \gamma'', \overline{x_i : \mathbb{T}_i}, x : \mathbb{T}'}
\\\\
	\infer[\textsc{crep\_2}]
	{
	\begin{array}{c}
	\exists \alpha, \gamma_r . 
	\gamma = \gamma'[x \mapsto \mathbb{T}] \cand
	\gamma' = \gamma'', \overline{x_i : \mathbb{T}_i} \cand
	\\
	\gamma'' = \gamma_r, x : \alpha \cand
	\free{\gamma_r}
	\end{array}
	}
	{
	\begin{array}{c}
	\begin{array}{ccc}
	x \notin \overline{x_i}
	&
	\fresh{\gamma_r}
	&
	\fresh{\alpha}
	\end{array}
	\\
	\gamma = \gamma'[x \mapsto \mathbb{T}] \cand
	\gamma' = \gamma'', \overline{x_i : \mathbb{T}_i} \cand
	\free{\gamma''}
	\end{array}
	}
\\\\
	\infer[\textsc{crep\_3}]
	{\mathbf{unbound}\:x}
	{
	\begin{array}{c}
	x \notin \overline{x_i}
	\\
	\gamma = \gamma'[x \mapsto \mathbb{T}] \cand
	\gamma' = \gamma'', \overline{x_i : \mathbb{T}_i} \cand
	\gamma'' = \emptyset
	\end{array}
	}
\\\\
	\infer[\textsc{cvar}]
	{\exists \gamma_r' . 
	\gamma = \gamma_r, \overline{x_i : \mathbb{T}_i} \cand
	\gamma_r = \gamma_r', x : \mathbb{T} \cand
	\free{\gamma_r'}
	}
	{
	\begin{array}{c}
	\begin{array}{cc}
	x \notin \overline{x_i}
	&
	\fresh{\gamma_r'}
	\end{array}
	\\
	\gamma = \gamma_r, \overline{x_i : \mathbb{T}_i} \cand 
	x : \mathbb{T} \in \gamma \cand
	\free{\gamma_r}
	\end{array}
	}
\\\\
	\infer[\textsc{cvar\_2}]
	{\mathbf{unbound}\:x}
	{x : \mathbb{T} \in \gamma \cand \gamma = \gamma', \overline{x_i : \mathbb{T}_i} \cand \gamma' = \emptyset
	&
	x \notin \overline{x_i}}
\\\\
	\infer[\textsc{cjoin}]
	{
	\begin{array}{c}
	\exists \overline{\alpha_i} .
	\gamma = \gamma_r, \overline{x_i : \alpha_i}
	\cand
	\overline{\alpha_i <: \mathbb{T}_i}
	\cand
	\overline{\alpha_i <: \mathbb{U}_i}
	\cand
	\\
	\gamma' = \gamma_r, \overline{x_i : \mathbb{T}_i}
	\cand
	\gamma'' = \gamma_r, \overline{x_i : \mathbb{U}_i}
	\end{array}
	}
	{
	\gamma = \gamma' \sqcup \gamma''
	\cand 
	\gamma' = \gamma_r, \overline{x_i : \mathbb{T}_i}
	\cand
	\gamma'' = \gamma_r, \overline{x_i : \mathbb{U}_i}
	}

\end{tabular}
\end{center}

\end{document}