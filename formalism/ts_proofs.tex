\documentclass{article}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{listings}
\usepackage{proof}
\usepackage{supertabular}
\usepackage{geometry}
\usepackage{color}
\usepackage{proof}
\usepackage{theorem}

\newtheorem{lem}{Lemma}
\newtheorem{thm}{Theorem}
\newtheorem{defn}{Definition}
\newtheorem{cor}{Corollary}

\newcommand{\Tr}{\mathit{Tr}}
\newcommand{\secref}[1]{Section \ref{#1}}
\newcommand{\figref}[1]{Figure \ref{#1}}
\newcommand{\lstref}[1]{Listing \ref{#1}}
\newcommand{\appref}[1]{Appendix \ref{#1}}
\newcommand{\lemref}[1]{Lemma \ref{#1}}

\newcommand{\rlett}{\textsc{r\_let\_term} }
\newcommand{\rletv}{\textsc{r\_let\_value} }
\newcommand{\rseqlt}{\textsc{r\_seq\_left\_term} }
\newcommand{\rseqlv}{\textsc{r\_seq\_left\_value} }
\newcommand{\rfunc}{\textsc{r\_fun\_call} }
\newcommand{\rmethc}{\textsc{r\_meth\_call} }
\newcommand{\rifexpr}{\textsc{r\_if\_term} }
\newcommand{\riftrue}{\textsc{r\_if\_true} }
\newcommand{\riffalse}{\textsc{r\_if\_false} }

\newcommand{\tunit}{\textsc{t\_unit} }
\newcommand{\ttrue}{\textsc{t\_true} }
\newcommand{\tfalse}{\textsc{t\_false} }
\newcommand{\tobj}{\textsc{t\_object} }
\newcommand{\tfundef}{\textsc{t\_fun\_def} }
\newcommand{\tlet}{\textsc{t\_let} }
\newcommand{\tif}{\textsc{t\_if} }
\newcommand{\tseq}{\textsc{t\_seq} }
\newcommand{\tfunc}{\textsc{t\_fun\_call} }
\newcommand{\tmethc}{\textsc{t\_meth\_call} }
\newcommand{\tdrop}{\textsc{t\_drop} }
\newcommand{\tsub}{\textsc{t\_sub} }
\newcommand{\tsubctx}{\textsc{t\_widen} }
\newcommand{\tnarrow}{\textsc{t\_narrow} }
\newcommand{\twiden}{\textsc{t\_widen} }

\newcommand{\typerule}[4]{#1 \triangleright #2 : #3 \triangleleft #4}
\newcommand{\oprule}[4]{#1 \mid #2\;\longrightarrow\;#3 \mid #4}
\newcommand{\inferrule}[4]{\llbracket #1 \triangleright #2 : #3 \triangleleft #4 \rrbracket}
\newcommand{\inferlhs}[1]{\llbracket \gamma \triangleright #1 : \alpha \triangleleft \gamma' \rrbracket}
\newcommand{\subst}[3]{#3 \{\overline{^{#1}/_{#2}}\}}
\newcommand{\substxy}[1]{\subst{x_i}{y_i}{#1}}
\newcommand{\unitv}{\mathtt{unit}}
\newcommand{\unitt}{\mathbf{Unit}}
\newcommand{\truev}{\mathtt{true}}
\newcommand{\falsev}{\mathtt{false}}
\newcommand{\boolt}{\mathbf{Bool}}
\newcommand{\funv}[4]{\lambda(\overline{#1 : #2 \gg #3}).#4}
\newcommand{\funt}[3]{(\overline{(#1 \gg #2) \rightarrow #3}}
\newcommand{\lett}[3]{\mathtt{let}\:#1\:\mathtt{=}\:#2\:\mathtt{in}\:#3}
\newcommand{\ift}[3]{\mathtt{if} \; #1 \; \mathtt{then} \; #2 \; \mathtt{else} \; #3}
\newcommand{\cand}{\:\wedge\:}
\newcommand{\free}[1]{\mathbf{free}\:#1}
\newcommand{\fresh}[1]{\mathbf{fresh}\:#1}

\newcommand{\qed}{$\blacksquare$}

\newenvironment{proof}{\vspace{1ex}\noindent{\bf Proof}\hspace{0.5em}}
  {\hfill\qed\vspace{1ex}}

\input{ts_defns}

\begin{document}

\title{TS1 - A simple linear calculus for typestate inference}
\author{Iain McGinniss}

\section{Grammar}

\ottgrammartabular{
\ottt\ottinterrule
\ottv\ottinterrule
\otto\ottinterrule
\ottT\ottinterrule
\ottO\ottinterrule
}

\section{Operational Semantics}

\ottgrammartabular{
\ottmu\ottinterrule
}

%\ottdefnvalidstore

\ottdefnreduce

\section{Type rules}
\label{sec:typerules}

\ottgrammartabular{
\ottG\ottinterrule
\ottT\ottinterrule
}

%\ottdefnvalidgamma

\ottdefnstoretype

\ottdefnmethtype

\ottdefnsubtype

\ottdefnobjeffextract

\ottdefntype

\section{Soundness proofs}

\subsection{Supporting lemmas}

\begin{lem}
\label{lem:valuectx}
If $v$ is a value and $\typerule{\Gamma}{v}{T}{\Gamma'}$, then $\Gamma = \Gamma'$.
\end{lem}
\begin{proof}
Directly from the typing judgements. $v$ is either {\tt unit}, {\tt true},
{\tt false}, a function literal or an object literal.
Correspondingly, by rules \tunit,
\ttrue, \tfalse, 
\tfundef and \tobj, $\Gamma = \Gamma'$.
\end{proof}

\begin{lem}[Object state sets]
An object type $O@S'$ is a subtype of $O@\overline{S}$ when $S' \in \overline{S}$.
\end{lem}
\begin{proof}
Let $S' \in \overline{S}$. The definition of $O@\overline{S}$ is
$\bigsqcup_{S \in \overline{S}}{O@S} = O@S' \sqcup \left( 
\bigsqcup_{S \in \overline{S} - \{ S' \}}{O@S} \right)$. 
By the definition of type join, $O@S' <: O@S' \sqcup \bigsqcup_{S \in \overline{S}}{O@S}$.
\end{proof}

\begin{lem}[Upgrading]
If a term $t$ can be typed such that 
$\typerule{\Gamma, x : T}{t}{U}{\Gamma', x : V}$, and if
$T' <: T$, then there exists a $V' <: V$ such that
$\typerule{\Gamma, x : T'}{t}{U}{\Gamma', x : V'}$.
\end{lem}
\begin{proof}
By induction on the structure of $t$.
The term $t$ is of one of the following forms:

\begin{itemize}
\item $t$ is a value, so by \lemref{lem:valuectx} it follows that
$\Gamma = \Gamma'$ and $T = V$. Let $V' = T'$.
The contexts for values can be arbitrary as long
as they are equal, therefore $\typerule{\Gamma, x : T'}{t}{U}{\Gamma', x : V'}$.

\item $t = \lett{y}{t'}{t''}$. It follows from the rule \tlet that
$x \neq y$ (as variables cannot be rebound) and that there exists 
$\Gamma_1, \Gamma_2, T_y, T_y'$ such that
$\typerule{\Gamma, x : T}{t'}{T_y}{\Gamma_1, x : T_2}$ and
$\typerule{\Gamma_1, x : T_2, y : T_y}{t''}{U}{\Gamma', x : T_3, y : T_y'}$.
By induction, it follows that there exists a type $V_2 <: T_2$ such that
$\typerule{\Gamma, x : T'}{t'}{T_y}{\Gamma_1, x : V_2}$.
As $V_2 <: T_2$, it also follows by induction that
$\typerule{\Gamma_1, x : V_2, y : T_y}{t''}{U}{\Gamma', x : T_3, y : V_3}$.
Let $V' = V_3$. The rules of \tlet are satisfied such that
$\typerule{\Gamma, x : T'}{t}{U}{\Gamma', x : V'}$.

\item $t = y ( \overline{z_i} )$. 
It follows from the rule \tfunc that there exists
$\Gamma_1, \overline{T_i}, \overline{U_i}, \overline{V_i}, \overline{T_i'}$ 
such that 
$\Gamma, x : T = \Gamma_1, y : \funt{U_i}{V_i}{U}, \overline{z_i : T_i}$
and that
$\Gamma', x : V = \Gamma_1, y : \funt{U_i}{V_i}{U}, \overline{z_i : T_i'}$
such that for each $i$, $T_i <: U_i$, $T_i' <: V_i$ 
and $U <: U'$.

There are three cases to consider:
\begin{itemize}
\item $x \neq y$ and $x \notin \overline{x_i}$, meaning that
$\Gamma_1 = \Gamma_2, x : T$ for some $\Gamma_2$, that
$\Gamma = \Gamma_2, y : \funt{U_i}{V_i}{U}, \overline{z_i : T_i}$
and that $\Gamma' = \Gamma_2, y : \funt{U_i}{V_i}{U}, \overline{z_i : T_i'}$.
Additionally, $T = V$. It follows that $t$ can be typed without $x$
such that $\typerule{\Gamma}{t}{U}{\Gamma'}$. Let $V' = T'$. 
By the weakening lemma, $\typerule{\Gamma, x : T'}{t}{T}{\Gamma', x : V'}$.

\item $x = y$, meaning $\Gamma = \Gamma_1, \overline{z_i : T_i}$ and
$\Gamma' = \Gamma_1, \overline{z_i : T_i'}$. 
Additionally, $T = V = \funt{U_i}{V_i}{U}$.
$T'$ must therefore be of form $\funt{U_i'}{V_i'}{U'}$ 
such that for each $i$, $U_i <: U_i'$, $V_i' <: V_i$, $U' <: U$ by the
definition of subtyping. Let $V' = T'$. 
It follows by rule \tfunc, and \tsub to replace $U'$ with $U$, that
$\typerule{\Gamma, x : T'}{x ( \overline{z_i})}{U}{\Gamma', x : V'}$.

\item $x \in \overline{z_i}$, meaning that $T = T_i$ and 
$V = T_i' = remap(T, U_i >> V_i)$ for some $i$. 
Let $V' = remap(T', U_i >> V_i)$.
The rule \tfunc permits $T$ to be replaced with $T'$
as $T' <: T$, such that
% MUST SHOW V' <: V$.
$\typerule{\Gamma, x : T'}{y ( \overline{z_i} )}{U}{\Gamma, x : V'}$.

\end{itemize}

\item $t = y.m$. By the rule $\tmethc$ it follows that
$\Gamma, x : T = \Gamma_1, y : O@\overline{S}$
and that
$\Gamma', x : V = \Gamma_1, y : O@\overline{S'}$
for some $\Gamma_1, O, \overline{S}$ and $\overline{S'}$
where
$\overline{S'} = \{ S_n | m : T_r \Rightarrow S_n \in O@S, S \in \overline{S} \}$.
Additionally, 
$U = \bigsqcup{ \{ T_r | m : T_r \Rightarrow S_n \in O@S, S \in \overline{S} \} }$.
There are two cases to consider:

\begin{itemize}
\item $x = y$. It follows that $\Gamma = \Gamma_1 = \Gamma'$ and
that $T = O@\overline{S}, V = O@\overline{S'}$.
$T'$ must be of form $O'@\overline{S}''$ such that
$O'@\overline{S}'' \sim O@\overline{S}$ by the definition of subtyping. 

Let $V' = O'@\overline{S}'''$
where
$S''' = \{ S_n' | m : T_r' \Rightarrow S_n' \in O'@S'', S'' \in \overline{S}''\}$.
Let $U' = \bigsqcup{ \{ T_r' | m : T_r' \Rightarrow S_n' \in O'@S'', S'' \in \overline{S}'' \} }$.
As $O'@\overline{S}'' \sim O@\overline{S}$, it follows that
$O'@\overline{S}''' \sim O@\overline{S}'$.
Therefore, $U' <: U$ and $V' <: V$. By the rule \tmethc, and \tsub
to replace $U'$ with $U$, it follows that
$\typerule{\Gamma, x : T'}{t}{U}{\Gamma', x : V'}$.

\item $x \neq y$. It follows that $\Gamma = \Gamma'', y : O@\overline{S}$
and that $\Gamma' = \Gamma'', y : O@\overline{S'}$
for some $\Gamma''$, $O$ and $\overline{S}$.
It follows that $\typerule{\Gamma}{t}{U}{\Gamma'}$.
Let $V' = T'$. By the weakening lemma, 
$\typerule{\Gamma, x : T'}{t}{U}{\Gamma', x : V'}$.
\end{itemize}

\item $t = t' ; t''$. It follows by rule \tlet that there exists
$\Gamma'', V_{mid}, U'$ 
such that $\typerule{\Gamma, x : T}{t'}{U'}{\Gamma'', x : V_{mid}}$
and that $\typerule{\Gamma'', x : V_{mid}}{t''}{U}{\Gamma', x : V}$.
By induction, it follows that there exists $V_{mid}'$ 
such that $\typerule{\Gamma, x : T'}{t'}{U'}{\Gamma'', x : V_{mid}'}$.
It also follows by induction that there exists $V_{end} <: V$
such that
$\typerule{\Gamma'', x : V_{mid}'}{t''}{U}{\Gamma'', x : V_{end}}$.
Let $V' = V_{end}$. By rule \tlet it follows that
$\typerule{\Gamma, x : T'}{t' ; t''}{U}{\Gamma'', x : V'}$.

\item $t = \ift{t_c}{t_t}{t_f}$. It follows from rule \tif that there
exists $\Gamma_1$, $\Gamma_2$, $\Gamma_3$, $U_t$, $U_f$, $V_c$, $V_t$ and
$V_f$
such that
$\typerule{\Gamma, x : T}{t_c}{\boolt}{\Gamma_1, x : V_c}$ and that
$\typerule{\Gamma_1, x : V_c}{t_t}{U_t}{\Gamma_2, x : V_t}$ and that
$\typerule{\Gamma_1, x : V_c}{t_f}{U_f}{\Gamma_3, x : V_f}$ with
$\Gamma' = \Gamma_2 \sqcup \Gamma_3$, $U = U_t \sqcup U_f$ and
$V = V_t \sqcup V_f$.

By induction, there exists a $V_c' <: V_c$, $V_t' <: V_t$ and $V_f' <: V_f$ 
such that $\typerule{\Gamma, x : T'}{t_c}{\boolt}{\Gamma_1, x : V_c'}$
and that $\typerule{\Gamma_1, x : V_c'}{t_t}{T_t}{\Gamma_2, x : V_t'}$
and that $\typerule{\Gamma_1, x : V_c'}{t_f}{T_f}{\Gamma_3, x : V_f'}$.
Let $V' = V_t' \sqcup V_f'$. By the definition of join, $V' <: V$.
It follows by rule \tif that
$\typerule{\Gamma, x : T'}{t}{U}{\Gamma', x : V'}$.

\end{itemize}

\end{proof}


\begin{lem}[Weakening]
If $\typerule{\Gamma}{t}{T}{\Gamma'}$,
then for all $\Gamma''$ such that $dom(\Gamma) \cap dom(\Gamma'') = \emptyset$,
$t$ can also be typed such that
$\typerule{\Gamma, \Gamma''}{t}{T}{\Gamma', \Gamma''}$.
\end{lem}
\begin{proof}
by induction on the structure of $t$.

If $t$ is some value $v$, it follows by \lemref{lem:valuectx} that 
$\Gamma = \Gamma'$ and that the typing derivation will still be valid as long
as the input and output contexts are identical. Therefore,
$\typerule{\Gamma , \Gamma''}{v}{T}{\Gamma', \Gamma''}$.

If $t$ is not a value, then it is of one of the following forms:

\begin{itemize}
\item $t = \lett{x}{t'}{t''}$. It follows from rule \tlet that
there exists $\Gamma_1, \Gamma_2, T', T''$ such that
$\typerule{\Gamma}{t'}{T'}{\Gamma_1}$ and
$\typerule{\Gamma_1, x : T'}{t''}{T}{\Gamma', x : T''}$.
By \tlet we have that $dom(\Gamma') = dom(\Gamma)$.
By induction, $t'$ can be typed such
that $\typerule{\Gamma,\Gamma''}{t'}{T'}{\Gamma_1,\Gamma''}$,
and $t''$ can be typed such that
$\typerule{\Gamma_1, \Gamma'', x : T'}{t''}{T}{\Gamma', \Gamma'', x : T''}$,
as we can assume by Barendregt's convention that $x$ can be made distinct from
any variable names in $\Gamma''$ by relabeling $x$.
Therefore,
$\typerule{\Gamma, \Gamma''}{\lett{x}{t'}{t''}}{T}{\Gamma', \Gamma''}$.

\item $t = x ( \overline{x_i} )$. It follows from the rule \tfunc that
there exists a $\Gamma_1, \overline{T_i}, \overline{U_i}, \overline{V_i}, \overline{T_i'}$ 
such that 
$\Gamma = \Gamma_1, x : (\overline{U_i \gg V_i}) \rightarrow T, \overline{x_i : T_i}$
and that
$\Gamma' = \Gamma_1, x : (\overline{U_i \gg V_i}) \rightarrow T, \overline{x_i : T_i'}$.
As $\Gamma_1$ can be arbitrary in the rule \tfunc, it follows that we
can extend the input and output contexts such that
$\typerule{\Gamma, \Gamma''}{x ( \overline{x_i} )}{T}{\Gamma', \Gamma''}$.

\item $t = x.m$. It follows from the rule \tmethc that there exists
a $\Gamma_1$ such that $\Gamma = \Gamma_1, x : O@\overline{S}$ and that 
$\Gamma' = \Gamma_1, x : O@\overline{S'}$.
As $\Gamma_1$ can be arbitrary in rule \tmethc, it follows that we can
extend the input and out contexts such that
$\typerule{\Gamma, \Gamma''}{x.m}{T}{\Gamma', \Gamma''}$.

\item $t = t' ; t''$. It follows from the rule \tseq that there exists
$\Gamma_1$ and $T'$ such that $\typerule{\Gamma}{t'}{T'}{\Gamma_1}$
and $\typerule{\Gamma_1}{t''}{T}{\Gamma'}$. By induction
$\typerule{\Gamma, \Gamma''}{t'}{T'}{\Gamma_1, \Gamma''}$
as $dom(\Gamma_1) \subseteq dom(\Gamma)$ and therefore
$\Gamma_1$ and $\Gamma''$ are disjoint.
Similarly, as $dom(\Gamma_1) = dom(\Gamma')$, by induction
$\typerule{\Gamma_1, \Gamma''}{t''}{T}{\Gamma', \Gamma''}$.
Therefore $\typerule{\Gamma, \Gamma''}{t'}{T'}{\Gamma_1, \Gamma''}$.

\item $t = \ift{t_c}{t_t}{t_f}$. It follows from rule \tif that there
exists $\Gamma_1$, $\Gamma_2$, $\Gamma_3$, $T_t$ and $T_f$ such that
$\typerule{\Gamma}{t_c}{\boolt}{\Gamma_1}$ and that
$\typerule{\Gamma_1}{t_t}{T_t}{\Gamma_2}$ and that
$\typerule{\Gamma_1}{t_f}{T_f}{\Gamma_3}$ with
$\Gamma' = \Gamma_2 \sqcup \Gamma_3$ and $T = T_t \sqcup T_f$.
By induction each of $\Gamma_1$, $\Gamma_2$ and $\Gamma_3$ can
be extended by $\Gamma''$ in the typing judgements for $t_c$,
$t_t$ and $t_f$. As $\Gamma'' \sqcup \Gamma'' = \Gamma''$, it
follows that $(\Gamma_2, \Gamma'') \sqcup (\Gamma_3, \Gamma'') = 
\Gamma_2 \sqcup \Gamma_3, \Gamma''$ and therefore $t$ can be
typed such that $\typerule{\Gamma, \Gamma''}{t}{T}{\Gamma', \Gamma''}$.

\end{itemize}

\end{proof}

\begin{lem}[Substitution]
If $\typerule{\Gamma}{t}{T}{\Gamma'}$, then
$\typerule
{\subst{x_i}{y_i}{\Gamma}}
{\subst{x_i}{y_i}{t}}
{T}
{\subst{x_i}{y_i}{\Gamma'}}$
where each $x_i$ and $y_i$ is distinct, and $\overline{x_i} \cap \overline{y_i} = \emptyset$.
\end{lem}
\begin{proof}
By induction on the structure of $t$.

If $t$ is some value $v$, then $\Gamma = \Gamma'$, therefore
$\subst{x_i}{y_i}{\Gamma} = \subst{x_i}{y_i}{\Gamma'}$
and substitution has no effect on the value, which has no specific requirements
of either $\Gamma$ or $\Gamma'$ other than that they are equal.
Therefore, $\typerule{\subst{x_i}{y_i}{\Gamma}}{\subst{x_i}{y_i}{v}}{T}{\subst{x_i}{y_i}{\Gamma'}}$.

If $t$ is a term, then it is of one of the following forms:

\begin{itemize}
\item $t = \lett{x}{t''}{t'}$. 
Substitution is defined on this term such that \\
$\subst{x_i}{y_i}{t} \equiv 
\lett{x}{( \subst{x_i}{y_i}{t''} )}{(\subst{x_j}{y_j}{t'})}$
, where $\overline{y_j} = \overline{y_i} - \{ x \}$.

By rule \tlet, it follows
that there exists $T', T'', \Gamma_1$ such that
$\typerule{\Gamma}{t''}{T''}{\Gamma_1}$ and that
$\typerule{\Gamma_1, x : T''}{t''}{T}{\Gamma', x : T'}$.
Additionally, $x \notin dom(\Gamma)$.

By induction, $t''$ can be substituted such that 
$\typerule
{\subst{x_i}{y_i}{\Gamma}}
{\subst{x_i}{y_i}{t''}}
{\subst{x_i}{y_i}{\Gamma_1}}
$.
Additionally, $t'$ can be substituted such that
$(\subst{x_j}{y_j}{\Gamma_1}) , x : T'' \triangleright \subst{x_j}{y_j}{t''} \triangleleft \{ (\overline{x_j / y_j} \} \Gamma') , x : T'$ as it is guaranteed that $x \notin \overline{y_j}$.
As $dom(\Gamma') = dom(\Gamma)$, and that $x \notin dom(\Gamma)$, it follows that $\subst{x_i}{y_i}{\Gamma_1} = (\subst{x_j}{y_j}{\Gamma_1})$ and
that $\overline{x_i / y_i} \} \Gamma' = \overline{x_j / y_j} \} \Gamma'$.

Therefore, the requirements of \tlet are satisfied such that
$\typerule{\subst{x_i}{y_i}{\Gamma}}{\subst{x_i}{y_i}{t}}{T}{\subst{x_i}{y_i}{\Gamma'}}$.

\item $t = t_l ; t_r$.
Substitution is defined on this term such that
$\{ \overline{x_i / y_i} \} ( t_l ; t_r ) \equiv \subst{x_i}{y_i}{t_l} ; \subst{x_i}{y_i}{t_r}$.

By rule \tseq, there exists $\Gamma'', T'$ such that
$\typerule{\Gamma}{t_l}{T'}{\Gamma''}$ and
$\typerule{\Gamma''}{t_r}{T}{\Gamma'}$. By induction,
$\typerule{\subst{x_i}{y_i}{\Gamma}}{\subst{x_i}{y_i}{t_l}}{T'}{\subst{x_i}{y_i}{\Gamma''}}$ and
$\typerule{\subst{x_i}{y_i}{\Gamma''}}{\subst{x_i}{y_i}{t_r}}{T}{\subst{x_i}{y_i}{\Gamma'}}$.
Therefore, $t$ can by typed \tseq after the substitution.

\item $t = x_0 ( \overline{x_k} )$.
Substition is defined on this term such that
$\subst{x_i}{y_i}{x_0} ( \overline{x_k} ) \equiv y_0 ( \overline{y_k} )$
where for each $x \in \{ x_0, \overline{x_k} \}$,
$x = y_j \implies y = x_j$, otherwise $y$ is the original value.

For each substitution that occurs in the term, the variable must exist in
both the input and output contexts by rule \tfunc, and will be substituted
for the same name. Therefore, $t$ can be typed by \tfunc after the
substitution.

\item $t = x.m$.
Substition is defined on this term such that
$\subst{x_i}{y_i}{x.m} \equiv y.m$
where $y = x_j$ if $x = y_j$ for some $y_j \in \overline{y_i}$.
Otherwise, $y = x$.

Rule \tmethc requires that $x$ exist in both $\Gamma$ and $\Gamma'$ and
therefore any substitution of x in the term will be matched with the
same substitution in the contexts. Therefore, $t$ can be typed by
\tmethc after the substitution.

\item $t = \ift{t_c}{t_t}{t_f}$. Substitution is defined on this term such
that \\
$\subst{x_i}{y_i}{(\ift{t_c}{t_t}{t_f})} \equiv 
\ift{\substxy{t_c}}{\substxy{t_t}}{\substxy{t_f}}$.
By rule \tif there exists $\Gamma_1$, $\Gamma_2$, $\Gamma_3$, $T_t$, $T_f$
such that
$\typerule{\Gamma}{t_c}{\boolt}{\Gamma_1}$ and that
$\typerule{\Gamma_1}{t_t}{T_t}{\Gamma_2}$ and that
$\typerule{\Gamma_1}{t_f}{T_f}{\Gamma_3}$ where
$\Gamma' = \Gamma_2 \sqcup \Gamma_3$ and $T = T_t \sqcup T_f$. By induction
substitution can be performed on $t_c$, $t_t$ and $t_f$ such that
$\typerule{\substxy{\Gamma}}{\substxy{t_c}}{\boolt}{\substxy{\Gamma_1}}$ and that
$\typerule{\substxy{\Gamma_1}}{\substxy{t_t}}{T_t}{\substxy{\Gamma_2}}$ and
$\typerule{\substxy{\Gamma_1}}{\substxy{t_f}}{T_f}{\substxy{\Gamma_3}}$.
By the definition of substitution on contexts, 
$\substxy{\Gamma_2} \sqcup \substxy{\Gamma_3} = \substxy{\Gamma'}$. Therefore,
by rule \tif, 
$\typerule{\substxy{\Gamma}}{\substxy{\ift{t_c}{t_t}{t_f}}}{T}{\substxy{\Gamma'}}$.
\end{itemize}
\end{proof}

\subsection{Progress and Preservation}

\begin{thm}[Progress and Preservation]
Given a term $t$ such that $\typerule{\Gamma}{t}{T}{\Gamma'}$
with a store $\mu$ such that $\Gamma \vdash \mu$, either $t$ is a value or 
there exist $t'$ and $\mu'$ such that
$\oprule{t}{\mu}{t'}{\mu'}$, with some $\Gamma''$ such that
$\Gamma'' \vdash \mu'$ and $\typerule{\Gamma''}{t'}{T}{\Gamma'}$.
\end{thm}

\begin{proof}
by induction on the structure of $t$. Assume $t$ is not a value. It is
therefore of one of the following forms:

\begin{itemize}
\item $t = \lett{x}{t''}{t'}$. 
It follows by rule \tlet that there exist $\Gamma_1, T', T''$
such that
$\typerule{\Gamma}{t''}{T'}{\Gamma_1}$ and that
$\typerule{\Gamma_1, x : T'}{t'}{T}{\Gamma', x : T''}$. There are two
possibilities:

	\begin{itemize}
	\item If $t''$ is some value $v$, then by \lemref{lem:valuectx} 
	we have that $\Gamma = \Gamma_1$ and reduction can occur
	by \rletv, such that 
	$\oprule{\lett{x}{v}{t'}}{\mu}{t'}{\mu [ x \mapsto v ]}$.
	Let $\mu' = \mu [ x \mapsto v ]$. Let $\Gamma'' = \Gamma, x : T'$.
	It follows that that $\Gamma'' \vdash \mu'$, with
	$\typerule{\Gamma''}{t'}{T}{\Gamma', x : T'}$.
	The requirements of rule \tdrop are satisfied by this, therefore we can 
	type $t'$ such that $\typerule{\Gamma''}{t'}{T}{\Gamma'}$.

	\item If $t''$ is a term, 
	by induction we have that $\oprule{t''}{\mu}{t'''}{\mu'}$, with
	$\Gamma'' \vdash \mu'$ and $\typerule{\Gamma''}{t'''}{T'}{\Gamma_1}$.
	This satisfies the requirements of \rlett, meaning $t$ itself can reduce
	such that $\oprule{\lett{x}{t''}{t'}}{\mu}{\lett{x}{t'''}{t'}}{\mu'}$.
	Additionally, the conditions of \tlet are satisfied such that
	$\typerule{\Gamma''}{\lett{x}{t'''}{t'}}{T}{\Gamma'}$.

	\end{itemize}

\item $t = t_l ; t_r$. It follows by rule
\tseq that $\typerule{\Gamma}{t_l}{T_l}{\Gamma_{mid}}$ and
$\typerule{\Gamma_{mid}}{t_r}{T}{\Gamma'}$.

	\begin{itemize}
	\item If $t_l$ is some value $v$, then
	reduction can occur by \\ 
	\rseqlv such that
	$t_l; t_r \mid \mu \longrightarrow t_r \mu$. By \lemref{lem:valuectx}, 
	$\Gamma'' = \Gamma = \Gamma_{mid}$
	and $\mu' = \mu$, therefore $\Gamma'' \vdash \mu'$ and 
	$\typerule{\Gamma''}{t_r}{T}{\Gamma'}$.

	\item If $t_l$ is a term, by induction $t_l \mid \mu \longrightarrow t_l' \mid \mu'$
	with some $\Gamma'' \vdash \mu'$ and
	$\typerule{\Gamma''}{t_l'}{T_l}{\Gamma_{mid}}$.
	This satisfies the requirements of \rseqlt
	such that $t_l; t_r \mid \mu \longrightarrow t_l'; t_r \mid \mu'$.
	Additionally, the requirements of \tseq are satisfied such that
	$\typerule{\Gamma''}{t_l'; t_r}{T}{\Gamma'}$.

	\end{itemize}

\item $t = x ( \overline{x_i} )$. It follows by rule \tfunc that
$\Gamma = \Gamma_1, \overline{x_i : T_i}$ 
with $\Gamma_1(x) = \funt{U_i}{V_i}{T}$
such that $\overline{T_i <: U_i}$ 
and that $\Gamma' = \Gamma_1, \overline{x_i : T_i'}$
where $T_i' = \mathbf{remap} ( T_i, U_i >> V_i )$.

As $\Gamma \vdash \mu$, 
it follows that $\mu(x) = \funv{y_i}{U_i'}{V_i'}{t'}$
where $\typerule{\overline{y_i : U_i'}}{t'}{T'}{\overline{y_i : V_i'}}$,
with $\funt{U_i'}{V_i'}{T'} <: \funt{U_i}{V_i}{T}$.
Additionally, $\mu(x_i) = v_i$ such that 
$\typerule{\emptyset}{v_i}{T_i''}{\emptyset}$ 
where $T_i'' <: T_i$ for each $x_i$.

Let $t_{sub} = \subst{x_i}{y_i}{t'}$.
The term $t$ can be reduced by \rfunc such that
$x ( \overline{x_i} ) \mid \mu \longrightarrow t_{sub} \mid \mu$.
By the substitution lemma, 
$\typerule{\overline{x_i : U_i'}}{t'}{T'}{\overline{x_i : V_i'}}$.
By applying the rules \tnarrow, \twiden and \tsub, it follows that
$\typerule{\overline{x_i : T_i}}{t'}{T}{\overline{x_i : V_i}}$
as $T_i <: U_i <: U_i'$ and $V_i' <: V_i$.

% NEED V_i <: T_i' to apply \twiden again.

Let $\mu' = \mu$. Let $\Gamma'' = \Gamma$. 

By applying the weakening lemma, we can type $t''$ such that
$\typerule{\Gamma''}{t''}{T}{\Gamma'}$,
with $\Gamma'' \vdash \mu'$.

\item $t = x.m$. It follows by rule \tmethc that
$\Gamma = \Gamma_1, x : O@\overline{S}$ and that 
$\Gamma' = \Gamma_1, x : O@\overline{S'}$, with
$\overline{S'} = \{ S_n | m : T_r \Rightarrow S_n \in O@S, S \in \overline{S} \}$.
As
$\Gamma \vdash \mu$, we must have $\mu = \mu_1, x \mapsto o'@S_c$ with
$\Gamma_1 \vdash \mu_1$ and where
$\typerule{\emptyset}{o'@S_c}{O'@S_c}{\emptyset}$ such that
$O'@S_c <: O@\overline{S}$. By the definition of subtyping for object types,
we must have that
$o' = [ S' \{ m = (v,S_n) ; ... \} ... ]$, where $O'@S_n <: O@\overline{S'}$. 
Where the value $v$ is concerned, $\typerule{\emptyset}{v}{T'}{\emptyset}$
for some $T'$ such that $T' <: T = \bigsqcup{ \{ T_r | m : T_r \Rightarrow S_n \in O@S, S \in \overline{S} \} }$.

Therefore reduction can occur by \rmethc such that
$x.m \mid \mu_1, x \mapsto o@S \longrightarrow v \mid \mu_1, x \mapsto o@S_n$.
Let $\mu' = \mu_1, x \mapsto o@S'$. Let $\Gamma'' = \Gamma'$. It follows that
$\Gamma'' \vdash \mu'$, as $O'@S_n <: O@\overline{S'}$. 
By application of the weakening lemma, we have that
$\typerule{\Gamma'}{v}{T'}{\Gamma'}$ and by rule \tsub and that
$\Gamma'' = \Gamma'$ we therefore have that 
$\typerule{\Gamma''}{v}{T}{\Gamma'}$.

\item $t = \ift{t_c}{t_t}{t_f}$. It follows by rule \tif that there exists
$\Gamma_1$, $\Gamma_2$, $\Gamma_3$, $T_t$ and $T_f$ such that
$\typerule{\Gamma}{t_c}{\boolt}{\Gamma_1}$ and that
$\typerule{\Gamma_1}{t_t}{T_t}{\Gamma_2}$ and that
$\typerule{\Gamma_2}{t_f}{T_f}{\Gamma_3}$ with
$\Gamma' = \Gamma_2 \sqcup \Gamma_3$ and $T = T_t \sqcup T_f$. There are
three possibilities for reduction:

	\begin{itemize}
	\item $t_c = \truev$. By \lemref{lem:valuectx} we have that
	$\Gamma = \Gamma_1$. Reduction can occur by \riftrue such that
	$\oprule{t}{\mu}{t_t}{\mu}$. By \tsub we have that
	$\typerule{\Gamma_1}{t_t}{T}{\Gamma_2}$ as $T_t <: T$. Additionally, for
	all $x \in \Gamma_2$, $\Gamma_2(x) <: \Gamma'(x)$. Therefore by
	repeatedly applying \tsubctx for all $x$, we have that
	$\typerule{\Gamma_1}{t_t}{T}{\Gamma'}$.
	Let $\Gamma'' = \Gamma$, $\mu' = \mu$ and 
	$t' = t_t$. Therefore, $\typerule{\Gamma''}{t'}{T}{\Gamma'}$ with
	$\Gamma'' \vdash \mu'$.

	\item $t_c = \falsev$. By \lemref{lem:valuectx} we have that
	$\Gamma = \Gamma_1$. Reduction can occur by \riffalse such that
	$\oprule{t}{\mu}{t_f}{\mu}$. By \tsub we hhave that
	$\typerule{\Gamma_1}{t_f}{T}{\Gamma_3}$ as $T_f <: T$. Additionally, for
	all $x \in \Gamma_3$, $\Gamma_3(x) <: \Gamma'(x)$. Therefore by
	repeatedly applying \tsubctx for all $x$, we have that
	$\typerule{\Gamma_1}{t_f}{T}{\Gamma'}$. Let $\Gamma'' = \Gamma$,
	$\mu' = \mu$ and $t' = t_f$. Therefore, 
	$\typerule{\Gamma''}{t'}{T}{\Gamma'}$ with $\Gamma'' \vdash \mu'$.

	\item $t_c$ is not a value. By induction, there exists $t_c'$,
	$\mu'$, $\Gamma''$ such that 
	$\oprule{t_c}{\mu}{t_c}{\mu'}$ and 
	$\typerule{\Gamma''}{t_c}{\boolt}{\Gamma_1}$ with $\Gamma'' \vdash \mu'$. 
	Reduction of $t$ can therefore occur by \rifexpr such that
	$\oprule{t}{\mu}{\ift{t_c'}{t_t}{t_f}}{\mu'}$. It follows
	by \tif that $\typerule{\Gamma''}{\ift{t_c'}{t_t}{t_f}}{T}{\Gamma'}$.
	\end{itemize}

\end{itemize}
\end{proof}

\section{Type inference}

Type inference in the style of Pottier, i.e. separate constraint generation
and constraint solving phases to determine the principal typing of a term,
can be defined by observing the requirements imposed by the typing judgements
defined in Section \ref{sec:typerules}.

\ottgrammartabular{
\ottC\ottinterrule
\ottctxc\ottinterrule
\otttyc\ottinterrule
\ottprotoc\ottinterrule
}

\[
\begin{array}{l}

% unit value
\inferlhs{\unitv} \triangleq \alpha = \unitt \cand \gamma = \gamma' 
\\\\

% true value
\inferlhs{\truev} \triangleq \alpha = \boolt \cand \gamma = \gamma' 
\\\\

% false value
\inferlhs{\falsev} \triangleq \alpha = \boolt \cand \gamma = \gamma' 
\\\\

% object value
\inferlhs{[ \overline{S_i \{ \overline{ m_{ij} = (v_{ij}, S_{ij}) } \} }]@S}
\triangleq
\exists \alpha_o, \alpha_s, \overline{\alpha_{ij}}, \overline{\gamma_{ij}} . \\
\alpha = \alpha_o@\alpha_s
\cand
\{ \overline{ S_i \{ \overline{ m_{ij} : \alpha_{ij} >> S_{ij} } \} }\}@S <: \alpha_o@\alpha_s
\cand
\gamma = \gamma'
\cand
\\
\overline{\gamma_{ij} = \emptyset}
\cand
\overline{\inferrule{\gamma_{ij}}{v_{ij}}{\alpha_{ij}}{\gamma_{ij}}}
\\\\

% function value
\inferlhs{\lambda ( \overline{x_i} ) . t} \triangleq
\exists \gamma_r, \gamma_a, \gamma_b, \overline{\alpha_{ai}}, \overline{\alpha_{bi}}, \alpha_r . \\
\alpha = (\overline{\alpha_{ai} \gg \alpha_{bi}}) \rightarrow \alpha_r
\cand
\gamma = \gamma'
\cand
\gamma_r = \emptyset
\cand \\
\gamma_a = \gamma_r, \overline{x_i : \alpha_{ai}}
\cand
\overline{x_i : \alpha_{bi} \in \gamma_b}
\cand
\inferrule{\gamma_a}{t}{\alpha_r}{\gamma_b} 
\\\\

% let binding
\inferlhs{\lett{x}{t'}{t}} \triangleq \exists \gamma_v, \gamma_{b1}, \gamma_{b2}, \alpha' . \\
\gamma_{b1} = \gamma_v, x : \alpha'
\cand
\gamma' = \gamma_{b2} - \{ x \}
\cand \\
\inferrule{\gamma}{t'}{\alpha'}{\gamma_v}
\cand
\inferrule{\gamma_{b1}}{t}{\alpha}{\gamma_{b2}}
\\\\

% update
\inferlhs{x\:\mathtt{:=}\:t'} \triangleq
\exists \gamma_a, \gamma_b, \alpha' . \\
\gamma_a = \gamma - \{ x \}
\cand
\gamma' = \gamma_b, x \mapsto \alpha'
\cand 
\alpha = \unitt
\cand \\
\inferrule{\gamma_a}{t'}{\alpha'}{\gamma_b}
\\\\

% sequence
\inferlhs{t ; t'} \triangleq
\exists \gamma'', \alpha' . \\
\inferrule{\gamma}{t}{\alpha'}{\gamma''}
\cand
\inferrule{\gamma''}{t'}{\alpha}{\gamma'}
\\\\

% function call
\inferlhs{x ( \overline{x_i} )} \triangleq
\exists \overline{\alpha_i}, \overline{\alpha_i'},\overline{\alpha_i''} . \\
x : ( \overline{\alpha_i \gg \alpha_i'} ) \rightarrow \alpha \in \gamma
\cand 
\overline{x_i : \alpha_i'' \in \gamma}
\cand
\\ 
\overline{\alpha_i'' <: \alpha_i}
\cand
\gamma' = \gamma [ \overline{x_i \mapsto \alpha_i'} ]
\\\\

% method call
\inferlhs{x.m} \triangleq
\exists \alpha_o, \alpha_s, \alpha_s' . \\
x : \alpha_o @ \alpha_s \in \gamma
\cand 
m : \alpha \gg \alpha_s' \in \alpha_o @ \alpha_s
\cand  \\
\gamma' = \gamma[ x \mapsto \alpha_o @ \alpha_s' ]
\\\\

% if-then-else
\inferlhs{\ift{t_c}{t_t}{t_f}} \triangleq
\\
\exists \alpha_c, \alpha_t, \alpha_f, \gamma_c, \gamma_t, \gamma_f . \\
\inferrule{\gamma}{t_c}{\alpha_c}{\gamma_c}
\cand
\inferrule{\gamma_c}{t_t}{\alpha_t}{\gamma_t}
\cand 
\\
\inferrule{\gamma_c}{t_f}{\alpha_f}{\gamma_f}
\cand
\alpha_c = \boolt
\cand
\\
\alpha_t <: \alpha
\cand
\alpha_f <: \alpha
\cand
\gamma' = \gamma_t \sqcup \gamma_f
\\\\

\end{array}
\]

\subsection{Context constraint solving}

Constraint solving is performed in phases. In the first phase, the context 
constraints
are normalised using the rules in \figref{fig:contextsolve} --- where the set of 
constraints in the premise exists, they are replaced with those in the 
conclusion. Normalisation means that every context variable will have a single 
defining constraint of form $\gamma = \emptyset$, $\free{\gamma}$ or
$\gamma = \gamma', \overline{x_i : \mathbb{T}_i}$, where $\gamma'$ is
either empty or free. A context $\Gamma$ for type checking can be easily
constructed from constraints in this form, as once the type variable
constraints are solved we can say $\Gamma = \overline{x_i : T_i}$ for
every $\gamma = \gamma', \overline{x_i : \mathbb{T}_i}$ where $T_i$ is the
solved form of $\mathbb{T}_i$.

The context normalisation rules do the following:

\begin{itemize}
\item \textsc{ceq} --- Where $\gamma$ is directly equivalent
to $\gamma'$, which is defined in terms of extension of
$\gamma''$, rewrite the constraints such that
$\gamma$ directly copies the extension of $\gamma''$.
\item \textsc{crem} --- Where $\gamma$ removes a variable $x$ from $\gamma'$,
which is defined in terms of extension of $\gamma''$, rewrite the
constraints such that $\gamma$ copies the extension of $\gamma''$ with
the variable $x$ removed from the extension. There is no need for an
error-producing variant of \textsc{crem}, where the variable $x$ is missing, 
as context removal constraints are always generated in a pair with a context 
extension constraint for let binding.
\item \textsc{cext} --- Where $\gamma$ extends $\gamma'$ with
a variable set $\overline{y_j}$, and $\gamma'$ is defined in terms of extension of
$\gamma''$ with a disjoint set of variables in its extension set, rewrite the
constraints such that $\gamma$'s extension set includes both the $y_j$
definitions and $x_j$ definitions.
\item $\textsc{cext}_2$ --- Where $\gamma$ extends $\gamma'$ with
a new variable $x$, and $\gamma'$ is defined in terms of extension of
some $\gamma''$ and the extension set already contains $x$, this
represents an attempt to redeclare $x$. As such, generate an error
$\mathbf{bound}\:x$, terminating the constraint solving process.
\item \textsc{crep} --- where $\gamma$ replaces the type of some
variable $x$ in $\gamma'$, where $\gamma$ is defined in terms of extension
of $\gamma''$ and $x$ is in the extension set, rewrite the constraints
such that $\gamma$ copies the extension set of $\gamma'$ with $x$
replaced as specified.
\item $\textsc{crep}_2$ --- where $\gamma$ replaces variable $x$ in
$\gamma'$ which is defined in terms of extension of $\gamma''$
which is free and $x$ is not in the extension set, $x$ is a
free variable in the term being processed. To introduce $x$ in such a way that
it will be included in all contexts, $\gamma''$ is redefined in
terms of extension of a new context $\gamma_r$ with variable $x$
in the extension set mapped to a new type variable $\alpha$. Following
this, \textsc{cext} can be applied to $\gamma'$, then \textsc{crep} can
be applied to $\gamma$.
\item $\textsc{crep}_3$ --- where $\gamma$ replaces variable $x$ in
$\gamma'$ which is defined in terms of an empty root $\gamma''$,
and $x$ is not in $\gamma$'s extension set, this indicates the usage
of an unbound variable within a function body. As such, generate an
error $\mathbf{unbound}\:x$ indicating that x is unbound within this
context, terminating the contraint solving process.
\item \textsc{cvar} --- where a variable constraint for $x$ exists
for context variable $\gamma$, which is defined in terms of
extension of $\gamma_r$ which is free, and $x$ is not in the extension
set of $\gamma$, $x$ is a free variable in the term being processed. 
Similar to $\textsc{crep}_2$, redefine $\gamma_r$
in terms of extension of a new root $\gamma_r'$, with $x$ in
the extension set with the observed type $\mathbb{T}$.
\item $\textsc{cvar}_2$ --- where a variable constraint for $x$ exists
for context variable $\gamma$, which is defined in terms of $\gamma'$
which is empty, and $x$ is not in the extension set of $\gamma$, 
$x$ is an unbound variable within a function body.
\end{itemize}

The rules are repeatedly applied to any matching sets of constraints
until no further rewriting is possible, producing either an error
or a set of context constraints which are fully normalised, and
can be converted into contexts for type checking easily.

The way in which the context constraints are generated guarantees
that the dependencies between contexts form a directed acyclic graph. For
this reason, we believe that that the first phase will always terminate,
but this has not yet been proven.

\begin{center}
\begin{tabular}{c}
	\infer[\textsc{ceq}]
	{\gamma = \gamma'', \overline{x_i : \mathbb{T}_i} \cand \gamma' = \gamma'', \overline{x_i : \mathbb{T}_i}}
	{\gamma = \gamma' \cand \gamma' = \gamma'', \overline{x_i : \mathbb{T}_i}}
\\\\
	\infer[\textsc{crem}]
	{
	\gamma = \gamma'', \overline{x_i : \mathbb{T}_i} \cand \gamma' = \gamma'', \overline{x_i : \mathbb{T}_i}, x : \mathbb{T}
	}
	{
	\gamma = \gamma' - \{x\} \cand \gamma' = \gamma'', \overline{x_i : \mathbb{T}_i}, x : \mathbb{T}
	}
\\\\
	\infer[\textsc{cext}]
	{\gamma = \gamma'', \overline{x_i : \mathbb{T}_i}, \overline{y_j : \mathbb{T}_j} \cand \gamma' = \gamma'', \overline{x_i : \mathbb{T}_i}}
	{
		\gamma = \gamma', \overline{y_j : \mathbb{T}_j} \cand \gamma' = \gamma'', \overline{x_i : \mathbb{T}_i}
		& \overline{y_j} \cap \overline{x_i} = \emptyset
	}
\\\\
	\infer[\textsc{cext\_2}]
	{\mathbf{bound}\:x}
	{
		\gamma = \gamma', \overline{y_j : \mathbb{T}_j}, x : \mathbb{T} \cand \gamma' = \gamma'', \overline{x_i : \mathbb{T}_i}
		& x \in \overline{x_i}
	}
\\\\
	\infer[\textsc{crep}]
	{\gamma = \gamma'', \overline{x_i : \mathbb{T}_i}, x : \mathbb{T} \cand
	\gamma' = \gamma'', \overline{x_i : \mathbb{T}_i}, x : \mathbb{T}'}
	{\gamma = \gamma'[x \mapsto \mathbb{T}] \cand
	\gamma' = \gamma'', \overline{x_i : \mathbb{T}_i}, x : \mathbb{T}'}
\\\\
	\infer[\textsc{crep\_2}]
	{
	\begin{array}{c}
	\exists \alpha, \gamma_r . 
	\gamma = \gamma'[x \mapsto \mathbb{T}] \cand
	\gamma' = \gamma'', \overline{x_i : \mathbb{T}_i} \cand
	\\
	\gamma'' = \gamma_r, x : \alpha \cand
	\free{\gamma_r}
	\end{array}
	}
	{
	\begin{array}{c}
	\begin{array}{ccc}
	x \notin \overline{x_i}
	&
	\fresh{\gamma_r}
	&
	\fresh{\alpha}
	\end{array}
	\\
	\gamma = \gamma'[x \mapsto \mathbb{T}] \cand
	\gamma' = \gamma'', \overline{x_i : \mathbb{T}_i} \cand
	\free{\gamma''}
	\end{array}
	}
\\\\
	\infer[\textsc{crep\_3}]
	{\mathbf{unbound}\:x}
	{
	\begin{array}{c}
	x \notin \overline{x_i}
	\\
	\gamma = \gamma'[x \mapsto \mathbb{T}] \cand
	\gamma' = \gamma'', \overline{x_i : \mathbb{T}_i} \cand
	\gamma'' = \emptyset
	\end{array}
	}
\\\\
	\infer[\textsc{cvar}]
	{\exists \gamma_r' . 
	\gamma = \gamma_r, \overline{x_i : \mathbb{T}_i} \cand
	\gamma_r = \gamma_r', x : \mathbb{T} \cand
	\free{\gamma_r'}
	}
	{
	\begin{array}{c}
	\begin{array}{cc}
	x \notin \overline{x_i}
	&
	\fresh{\gamma_r'}
	\end{array}
	\\
	\gamma = \gamma_r, \overline{x_i : \mathbb{T}_i} \cand 
	x : \mathbb{T} \in \gamma \cand
	\free{\gamma_r}
	\end{array}
	}
\\\\
	\infer[\textsc{cvar\_2}]
	{\mathbf{unbound}\:x}
	{x : \mathbb{T} \in \gamma \cand \gamma = \gamma', \overline{x_i : \mathbb{T}_i} \cand \gamma' = \emptyset
	&
	x \notin \overline{x_i}}
\\\\
	\infer[\textsc{cjoin}]
	{
	\begin{array}{c}
	\exists \overline{\alpha_i} .
	\gamma = \gamma_r, \overline{x_i : \alpha_i}
	\cand
	\overline{\alpha_i <: \mathbb{T}_i}
	\cand
	\overline{\alpha_i <: \mathbb{U}_i}
	\cand
	\\
	\gamma' = \gamma_r, \overline{x_i : \mathbb{T}_i}
	\cand
	\gamma'' = \gamma_r, \overline{x_i : \mathbb{U}_i}
	\end{array}
	}
	{
	\gamma = \gamma' \sqcup \gamma''
	\cand 
	\gamma' = \gamma_r, \overline{x_i : \mathbb{T}_i}
	\cand
	\gamma'' = \gamma_r, \overline{x_i : \mathbb{U}_i}
	}

\end{tabular}
\end{center}

\end{document}