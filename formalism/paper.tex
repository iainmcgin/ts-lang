\documentclass[preprint]{sigplanconf}

% The following \documentclass options may be useful:
%
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% authoryear    To obtain author/year citation style instead of numeric.

\usepackage{amsmath}
\usepackage{listings}
\usepackage{proof}
\usepackage{supertabular}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{theorem}
\usepackage{url}
\usepackage{graphicx}
\usepackage{mathtools}

\DeclareSymbolFont{symbolsC}{U}{ntxsyc}{m}{n}
\SetSymbolFont{symbolsC}{bold}{U}{ntxsyc}{b}{n}
\DeclareMathSymbol{\sqcupplus}{\mathbin}{symbolsC}{124}

\newtheorem{lem}{Lemma}
\newtheorem{thm}{Theorem}
\newtheorem{defn}{Definition}
\newtheorem{cor}{Corollary}

\newcommand{\Tr}{\mathit{Tr}}
\newcommand{\secref}[1]{Section \ref{#1}}
\newcommand{\figref}[1]{Figure \ref{#1}}
\newcommand{\lstref}[1]{Listing \ref{#1}}
\newcommand{\appref}[1]{Appendix \ref{#1}}
\newcommand{\thmref}[1]{Theorem \ref{#1}}
\newcommand{\lemref}[1]{Lemma \ref{#1}}
\newcommand{\corref}[1]{Corollary \ref{#1}}

\newcommand{\rlett}{\textsc{r\_let\_term} }
\newcommand{\rletv}{\textsc{r\_let\_value} }
\newcommand{\rseqlt}{\textsc{r\_seq\_left\_term} }
\newcommand{\rseqlv}{\textsc{r\_seq\_left\_value} }
\newcommand{\rfunc}{\textsc{r\_fun\_call} }
\newcommand{\rmethc}{\textsc{r\_meth\_call} }
\newcommand{\rifexpr}{\textsc{r\_if\_term} }
\newcommand{\riftrue}{\textsc{r\_if\_true} }
\newcommand{\riffalse}{\textsc{r\_if\_false} }

\newcommand{\tunit}{\textsc{t\_unit} }
\newcommand{\ttrue}{\textsc{t\_true} }
\newcommand{\tfalse}{\textsc{t\_false} }
\newcommand{\tobj}{\textsc{t\_object} }
\newcommand{\tfundef}{\textsc{t\_fun\_def} }
\newcommand{\tlet}{\textsc{t\_let} }
\newcommand{\tif}{\textsc{t\_if} }
\newcommand{\tseq}{\textsc{t\_seq} }
\newcommand{\tfunc}{\textsc{t\_fun\_call} }
\newcommand{\tmethc}{\textsc{t\_meth\_call} }
\newcommand{\tdrop}{\textsc{t\_drop} }
\newcommand{\tsub}{\textsc{t\_sub} }
\newcommand{\tnarrow}{\textsc{t\_narrow} }
\newcommand{\twiden}{\textsc{t\_widen} }

\newcommand{\subrefl}{\textsc{sub\_refl}}
\newcommand{\subtrans}{\textsc{sub\_trans}}
\newcommand{\subfn}{\textsc{sub\_fn}}
\newcommand{\subobj}{\textsc{sub\_obj}}

\newcommand{\remapunit}{\textsc{remap\_unit}}
\newcommand{\remapbool}{\textsc{remap\_bool}}
\newcommand{\remapfunc}{\textsc{remap\_func}}
\newcommand{\remapobj}{\textsc{remap\_obj}}

\newcommand{\remapapp}[3]{\ensuremath{\mathbf{remap}(#1, #2 \gg #3)}}

\newcommand{\typerule}[4]{#1 \triangleright #2 : #3 \triangleleft #4}
\newcommand{\oprule}[4]{#1 \mid #2\;\longrightarrow\;#3 \mid #4}
\newcommand{\inferrule}[4]{\left\llbracket #1 \triangleright #2 : #3 \triangleleft #4 \right\rrbracket}
\newcommand{\inferlhs}[1]{\left\llbracket \gamma \triangleright #1 : \alpha \triangleleft \gamma' \right\rrbracket}
\newcommand{\subst}[3]{#3 \{\overline{^{#1}/_{#2}}\}}
\newcommand{\substo}[3]{#3 \{^{#1}/_{#2}\}}
\newcommand{\substxy}[1]{\subst{x_i}{y_i}{#1}}
\newcommand{\unitv}{\mathtt{unit}}
\newcommand{\unitt}{\mathbf{Unit}}
\newcommand{\truev}{\mathtt{true}}
\newcommand{\falsev}{\mathtt{false}}
\newcommand{\boolt}{\mathbf{Bool}}
\newcommand{\ot}[2]{#1@\overline{#2}}
\newcommand{\funv}[4]{\lambda(\overline{#1 : #2 \gg #3}).#4}
\newcommand{\funt}[3]{(\overline{#1 \gg #2}) \rightarrow #3}
\newcommand{\lett}[3]{\mathtt{let}\:#1\:\mathtt{=}\:#2\:\mathtt{in}\:#3}
\newcommand{\ift}[3]{\mathtt{if} \; #1 \; \mathtt{then} \; #2 \; \mathtt{else} \; #3}

\newcommand{\cand}{\:\wedge\:}
\newcommand{\free}[1]{\mathbf{free}\:#1}
\newcommand{\fresh}[1]{\mathbf{fresh}\:#1}
\newcommand{\partialo}[2]{\mathbf{partial}\:\overline{\mathbb{S}_{#1}{#2}}}
\newcommand{\fixedo}[2]{\mathbf{fixed}\:\overline{\mathbb{S}_{#1}{#2}}}
\newcommand{\os}[2]{\omega_{#1}@\sigma_{#2}}

\newcommand{\tinf}{\mathbb{T}}

\newcommand{\qed}{$\blacksquare$}

\newenvironment{proof}{\vspace{1ex}\noindent{\bf Proof}\hspace{0.5em}}
  {\hfill\qed\vspace{1ex}}

\lstset{
    basicstyle=\ttfamily \small,
    numbers=left,
    frame=single,
    tabsize=2,
    xleftmargin=2.0em,
    xrightmargin=0.4em
}

\input{ts_defns}

\begin{document}

\conferenceinfo{TBD}{TBD} 
\copyrightyear{2012} 
\copyrightdata{[to be supplied]} 

\titlebanner{IN-PROGRESS WORK}        % These are ignored unless
\preprintfooter{DO NOT REDISTRIBUTE WITH PERMISSION}   % 'preprint' option specified.

\title{Typestate Inference in an Imperative Calculus}

\authorinfo{Iain McGinniss \and Simon Gay}
           {University of Glasgow}
           {\{iainmcgin, simon\}@dcs.gla.ac.uk}

\maketitle

\begin{abstract}
Current typestate research is primarily focused on studying
type systems that can support particular use cases;
the type systems are often complex, and programs in such languages 
require large type annotations to allow for full static type checking. Little
work has been done to determine whether inference of such annotations is 
feasible. We present a small imperative calculus which
models interactions with typestate-constrained objects and a type inference
technique which can derive principal typings for terms with some
restrictions, and therefore eliminate the need for
explicit type annotations in most cases.
\end{abstract}

\category{D.2.4}{Software Engineering}{Programming by contract}
\category{F.3.3}{Studies of Program Constructs}{Type structure}
\category{D.1.5}{Object-oriented Programming}{}
\category{D.3.1}{Programming Languages}{Formal Definitions and Theory}

\keywords
typestate, type inference, constraint solving, alias control

\section{Introduction}

Typestate is ubiquitous in object oriented programs \cite{Beckman2011} and yet
very few languages provide direct support for it. Stateful objects are a source
of subtle runtime errors when their contracts are not respected, as the
point of failure is often separated from the cause in both source location
and time. As such the use of immutable objects and the 
borrowing of ideas from functional programming has become much more prevalent, 
such as in languages like Scala and Rust \cite{Rust}.

Immutability runs contrary to what objects were intended to be --- objects in
their most fundamental form can be viewed as entities with private state and 
associated protocols, which specify the messages the entities can respond to.
An immutable object, meaning an object with constant private state and
a stateless protocol, has much more in common with a type constructor in 
a functional language.

An object may have a very simple 
protocol, where the set of messages (or equivalently, method calls) it is 
willing to accept is constant throughout its lifecycle --- this is what the 
type system of programming languages such as Java can express. This is
insufficient to correctly model the object's behaviour in many cases, as
the set of messages the object can correctly respond to is dependent upon
its private state. State change is typically synchronous, in 
response to message receipt, and safety requires that 
any message sent to an object is within the set which can be received for
the current state. The private state can often be abstracted
such that restrictions on sequences of messages can be expressed as a
deterministic finite state machine.

Describing the allowed sequence of messages which a class of objects can
receive, their typestate, produces significantly more complex types than
in an object oriented language without typestate constraints. Functions which
take objects as parameters must describe the type of object they accept,
in which state, and what state transformation will occur (which may not
be deterministic). This type annotation burden is particularly heavy
in a language with function literals, which must be succinct
in order to be practical.

Static checking of typestate requires
that the current state of an object always be known at a point of invocation.
This is only possible when an alias control strategy is employed, such as linear
types, but such types prohibit programming in a style that most programmers are 
familiar with. Attempting to relax linear typing through the use of fractional 
permissions as in Plural and Plaid \cite{Aldrich2009,Bierhoff2009}
adds further complexity to the type system. This results in 
large type annotations within programs to express both typestate and aliasing 
constraints when modular static type checking is desired.
If it were possible to eliminate the need for such type annotations in
most situations, code could be more concise and readable, with annotations
reserved for situations where inference is not possible or are required
for formal documentation purposes.

\section{Modelling typestate constraints}
\label{sec:tsmodel}

In previous work \cite{McGinniss2011}, we have taken the view that most use 
cases for typestate can be adequately modelled by a deterministic
finite state machine. The state machine explicitly describes the
states of the object, the methods which can be called in each state and
the transition triggered by a method call in a specific state.
Fields on the object can either be treated as private or as a special case
of method invocation \cite{Abadi1996}. For simplicity
we will only consider methods with no parameters, as there are very few
use cases where the values of parameters have an effect on state transition 
decisions which could be described without the integration of much more
complex features into the model, such as range types, conditional transitions
or a full logical framework.

The type of a given object at any point in time can be described as the
combination of a state machine (which we will refer to as the 
{\it object protocol}) and a particular state from within that protocol.
We write this as $O@S$, where $O$ is the protocol and $S$ is the state.
Formally, an object protocol $O$ is defined as a triple
$\langle M, \Sigma, \Delta \rangle$ where $M$ is a set of all
method names, $\Sigma$ is the set of state labels and
$\Delta \subseteq \Sigma \times M \times \Sigma$ is the state
transition relation. Transitions for a given state must be unique, such that 
$(S, m, S') \in \Delta \implies \nexists S'' \:\mathrm{st.}\: S' \neq S'' 
\wedge (S, m, S'') \in \Delta$.

The subtyping relation $<:$ is defined in terms of a
{\it simulation preorder}. Given $O = \langle M, \Sigma, \Delta \rangle$ and
$O_2 = \langle M_2, \Sigma_2, \Delta_2 \rangle$, the simulation preorder
$\precsim$
is defined to be the largest relation such that if $O@S \precsim O_2@S_2$ then for all
$m$ and $S_4$ such that $(S_2, m, S_4) \in \Delta_2$ there exists an $S_3$ such that
$(S, m, S_3) \in \Delta$ and that $O@S_3 \precsim O_2@S_4$.
Subtyping is defined such that $O@S <: O_2@S_2 \iff O@S \precsim O_2@S_2$.

A perhaps more intuitive basis for subtyping is {\it trace inclusion}. The set 
of interaction traces $\Tr(O@S)$ of a type is the smallest set such that:

\[
\begin{tabular}{cc}
\infer{\epsilon \in \Tr(O@S)}{}
&
\infer{m . t \in \Tr(O@S)}
{(S, m, S') \in \Delta & t \in \Tr(O@S')}
\end{tabular}
\]

where $\epsilon$ is the empty trace, and $m . t$ is the 
prefixing of an existing trace with a method call.
Subtyping is therefore defined such that
$O@S <: O_2@S_2 \iff \Tr(O_2@S_2) \subseteq \Tr(O@S)$. 

It is easy to
show that $O@S \precsim O_2@S_2 \iff \Tr(O_2@S_2) \subseteq \Tr(O@S)$, so these
interpretations of subtyping can be used interchangeably wherever necessary.

Either view of subtyping is comparable to the Liskov substitution 
principle \cite{Liskov1987} --- a type must accept every sequence of
method calls that a supertype would, therefore it is a {\it behavioural}
subtype.

\section{TS - an imperative calculus with typestate}

TS is a small imperative calculus which models interactions with 
typestate-constrained objects, supports function literals without 
implicit capture, and employs structural subtyping for function and object
types.
The grammar of the language is shown 
in \figref{fig:grammar}, with operational semantics in \figref{fig:opsemantics} 
and typing rules in \figref{fig:typerules}.
The language is designed primarily
to study typestate inference in imperative code, rather than to 
be practical, general purpose programming language. The language uses syntactic 
control of interference \cite{Reynolds1978} to avoid the issue of alias control 
entirely - there is no means within the language to produce an alias to an 
object. This focuses attention on the fundamentals of typestate inference.

The language has the following values:

\begin{itemize}
\item {\tt unit}, the sole value of the {\tt Unit} type, which is used as
the result type for terms which have no meaningful result.

\item {\tt true} and {\tt false}, of type {\tt Bool}, which are used for
decisions in conditional evaluation. The language contains no operations
for manipulating booleans, to keep the calculus small, however
such operations would be straightforward to add.

\item Function literals of form $\funv{x_i}{T_i}{T_i'}{t}$, where
$\overline{x_i}$ is the set of parameters to the function while
$t$ is the body term. Parameters are passed by reference.
Function literals do not allow for implicit capture
of variables into their scopes --- everything must be passed as a parameter. 
Tracking effects on implicitly captured references is not well understood
in the current literature outside of strict linear types where
function literals that capture linear references must themselves be linear.
Requiring that all references be explicitly passed to the function allows for
effects to be explicitly declared. The notation $T \gg T'$ is used to
describe an {\it effect type}, which declares a required type for the parameter 
on the left, and the new type of the parameter after application of the function 
on the right. Not all effect types are legal, as will be discussed later.

\item Object literals of form 
$O@S$, where $O = \left[ \overline{ S_i \{ m_{ij} = (v_{ij}, S_{ij}) \} } \right]$. 
$O$ is the object protocol, and $S$ is the current state
(where $S \in \overline{S_i}$). The object protocol contains a set of
distinct state labels $\overline{S_i}$, within which is a set of methods 
$\overline{m_{ij}}$ 
which can be called in that state. The language does
not attempt to fully model the behaviour of objects, only interactions with
them. As such, it is sufficient for each method to be defined as a pair 
consisting of the return value of the method, and the next state of the object 
if the method is invoked. Non-determinism in the production of a return value 
could be simulated by specifying a set of possible return values and allowing 
the operational semantics to select one of these randomly.
All values would have to have the same type, or types for which a least upper 
bound exists. Such non-determinism would have no effect on the type system,
which is the main focus of this paper.
\end{itemize}

\noindent
The language has the following terms:

\begin{itemize}
\item A conditional of form $\ift{t_c}{t_t}{t_f}$, which evaluates
$t_c$ first to a boolean result which decides which of $t_t$ 
(the \"true\" branch) or $t_f$ (the \"false\" branch) is
evaluated.
\item Function calls of form $x(\overline{x_i})$, which extract the function
literal stored in $x$ and apply it to the set of parameters $\overline{x_i}$,
which must match the declared parameter types. Each $x_i$ must be a distinct
variable, and is passed by reference, allowing the type of $x_i$ to be changed
as a result of the function application.
\item Method invocations on objects of form $x.m$. A method call is only
valid when the method is available in the current state of the object stored
in $x$. After a valid invocation, the state of the object will have changed
as specified by the object's protocol.
\item A let-bind construct $\lett{x}{t}{t'}$, which creates a new variable
$x$ within the scope of the body term $t'$ which is a reference to the value
derived from the term $t$. Rebinding a variable name is not allowed.
\item Sequencing of form $\tseq{t}{t'}$, which evaluates terms in 
left-to-right order.
\end{itemize}

While variables are references to a value, there is no construct which
can duplicate a reference. This very simple mechanism
ensures that references are unique, allowing us to focus our attention on the
typestate properties of objects without the added complication of alias
control annotations in the types. The restriction that each variable passed to
a function be unique is for this reason, to prevent implicit duplication
by passing the same variable more than once to the same function.

\begin{figure}

\ottgrammartabular{
\ottt\ottinterrule
\ottv\ottinterrule
\otto\ottinterrule
\ottT\ottinterrule
\ottO\ottinterrule
}

\caption{\label{fig:grammar} Grammar of TS0}
\end{figure}

The example in \figref{fig:exampleprog} shows a short TS0 program
that emulates the usage of an iterator. The object {\tt it}
provides an iterator-like contract, starting in the state {\tt CHECK} where
only the method {\tt hasNext} can be called, which returns a boolean value.
This method changes the state of the object to {\tt READ}, where both
{\tt hasNext} and {\tt next} can be called. Calling {\tt next} changes the
state of the object back to {\tt CHECK}. While the language does not
support {\it conditional transitions} that would be necessary to express
the restriction that {\tt next} should only be callable after {\tt hasNext}
returns {\tt true}, it does still provide more protection than a language
without typestate would.

\begin{figure}
\begin{lstlisting}
let it = [ CHECK { hasNext = (true,READ) } 
          READ  { hasNext = (true,READ);
                  next = (unit,CHECK) }
        ]@CHECK in
let console = [S { print = (unit,S) }]@S in
let f = \(x).(if x.hasNext 
              then (x.next ; true) 
              else false) in
if f(it) then console.print else unit
\end{lstlisting}
\caption{\label{fig:exampleprog} An example program in TS0}
\end{figure}

The object {\tt console} is effectively stateless, allowing the method
{\tt print} to be called without restriction.

The function {\tt f} will call {\tt hasNext}, and if it returns true then
will call {\tt next}. It returns a boolean value indicating whether
{\tt next} was called.

Finally, the object {\tt it} is passed to {\tt f} and {\tt print} will
be called on {\tt console} if {\tt f} returns true. Given the fixed return
values for the methods on {\tt it}, {\tt print} will always be called.

The most interesting part of the program is the function literal assigned
to {\tt f}. What is the effect type for the parameter {\tt x}? 
This is the only piece of type information that cannot be determined
easily, and is key to determining whether {\tt f} would use {\tt it} in
a safe manner.

\subsection{Stores}

Each variable is a unique reference to a value in a store $\mu$, which is 
defined as $\mu\:\mathrm{::=}\:\overline{x_i \mapsto v_i}$ where each $x_i$ is
distinct. A store location
is created (or overwritten) upon entry to the body of a let-binding, written as
$\mu[x \mapsto v]$, which is defined as follows:

\[
\begin{tabular}{cc}
\infer
{\mu[x \mapsto v] = \mu, x \mapsto v}
{\mu = \overline{x_i \mapsto v_i} & x \notin \overline{x_i}}
&
\infer
{\mu[x \mapsto v] = \overline{x_i \mapsto v_i} , x \mapsto v}
{\mu = \overline{x_i \mapsto v_i}, x \mapsto v'}
\end{tabular}
\]

As there is no way for a reference to be duplicated, the mapping
from variable names to store locations is injective and therefore we have
no need for explicit ``location values'' as in the typical treatment of 
languages with references (such as in \cite{Pierce2002}). There is no need
for a separate store typing, as a well-typed store can be defined directly
in relation to a context as in \figref{fig:storetype}. A well-typed store
may contain mappings for variables which are not in the context as shown in
rule \textsc{st\_extra}. Such mappings are candidates for garbage collection,
or an explicit deallocation instruction could be injected after the
evaluation of the body of a let-binding.

\begin{figure}

\ottdefnreduce

\caption{\label{fig:opsemantics} Operational semantics}
\end{figure}

\subsection{Type system}

As the language is imperative and the types of variables pointing to objects can
change, it is necessary for the typing judgements to express changes to the 
environment. We must then be able
to prove that the changes in the environment correspond to the changes in the
store during evaluation. A context $\Gamma$ is a set of unique variable names 
mapped to types, defined as $\Gamma\:\mathrm{::=}\:\overline{x_i : T_i}$,
with each $x_i$ distinct. \figref{fig:storetype} defines what it means for
a store to be well-typed with respect to a
context. \figref{fig:typerules} defines the rules for well-typed terms
in the language, while \figref{fig:subtyperules} defines the subtyping
relation.

The type system of TS is sound (it has both progress and type preservation
properties), which is proven in \thmref{thm:soundness} in 
\appref{app:soundness}.

\begin{figure}
\begin{ottdefnblock}
{$\Gamma  \vdash  \mu$}
{\ottcom{store $\mu$ is well typed against context $\Gamma$}}
\end{ottdefnblock}

\[
\begin{tabular}{cc}
\infer[\textsc{st\_empty}]
{\emptyset \vdash \emptyset}
{}
&
\infer[\textsc{st\_vars}]
{\overline{x_i : T_i} \vdash \overline{x_i \mapsto v_i}}
{\overline{\typerule{\Gamma}{v_i}{T_i}{\Gamma'}}}
\\\\
\multicolumn{2}{c}{
\infer[\textsc{st\_extra}]
{\Gamma \vdash \mu, \overline{x_i \mapsto v_i}}
{\Gamma \vdash \mu & \overline{x_i \notin dom(\mu)}}
}
\end{tabular}
\]

\caption{\label{fig:storetype} Store typing judgements}
\end{figure}

\begin{figure}
\ottdefnmethtype

\ottdefntype

\caption{\label{fig:typerules} Type rules}
\end{figure}

\begin{figure}

\ottdefnsubtype

\caption{\label{fig:subtyperules} Subtyping rules}
\end{figure}

There are four kinds in the type system: Unit, Bool, function types and 
object types.
Two modifications are made to the definition of object protocols described
in \secref{sec:tsmodel}: methods have return types, and an object type
is the combination of an object protocol and a {\it set} of states.
An object protocol $O$ is therefore formally defined as the tuple 
$O = \langle M, \Sigma, \Delta \rangle$
where the transition relation $\Delta \subseteq \Sigma \times M \times T \times \Sigma$, 
where $T$ is the set of all types in the language.

While an object value in TS is still deterministic and has a single state at any 
given
point in time, we may not be able to determine in the type system which state 
exactly it is in --- conditional evaluation readily produces this situation.
With an if-then-else expression where the branches
interact with an object differently, it is common for the state of the object
at the end of each branch to be different. As
knowing precisely which branch will be taken statically is rarely possible, 
we must either insist that the state of the object
be the same upon exit from both branches, or devise a means to cope with
the object being in one of multiple potential states. We choose the latter
approach, as it is both more flexible and allows for intuitive principal
types to be chosen, as will be discussed later.


% abandoned attempt to define join/meet
% \begin{figure}

% \[
% \begin{array}{c}
% \infer[\sqcap-state]
%   {S \sqcup S_2 = \{ \overline{ m : T'' \Rightarrow (S_3 \sqcap S_4)} \} }
%   {
%   m : T \Rightarrow S_3 \in O@S
%   &
%   m : T' \Rightarrow S_4 \in O_2@S_2
%   &
%   T'' = T \sqcup T'
%   }
% \\
% \infer[\sqcup-omg]
%   {S \sqcup S_2 = 
%   \{ \overline{ m : T'' \Rightarrow (S_3 \sqcup S_4} \} } 
%   \cup
%   \{ \overline{ m' : T_3 \Rightarrow S_4 \} }
%   {}
% \]

% \caption{\label{fig:joinmeet} Join/meet definition}
% \end{figure}

An object type in TS, written $O@\overline{S}$, is equivalent to
$\bigsqcup_{S \in \overline{S}} O@S$, where $T \sqcup T'$ is the least upper
bound (or {\it join}) of $T$ and $T'$. Deriving a least upper bound for
two arbitrary object types (with a single current state) 
involves constructing the intersection of the state machines for each object 
type, using the current state of each object type as the initial state.
Similarly, deriving a greatest lower bound is based upon the union of
the two state machines in the same fashion. Join is always defined for
object types, while meet is not. Consider the two object types
$\{ S \{ m : \unitt \Rightarrow S \} \}@S$ and
$\{ S \{ m : \boolt \Rightarrow S \} \}@S$. The meet of these two types
requires that method $m$ is callable, but $\unitt \sqcap \boolt$ is undefined
and therefore no return type can be assigned to the method $m$.

The intuition for state sets is that the only sequences of method calls which 
can be safely invoked on an object of type $O@\overline{S}$ are those which 
could be safely invoked on each individual $O@S$, where $S \in \overline{S}$.

In general, the set of
types in TS is a join semi-lattice, with $\top$ as the greatest element.
The greatest element within object types exclusively is $\{ S \{\} \}@S$,
that is, an object which allows no method calls.


\subsection{Extra notational conventions}

Given an object type $O@\overline{S}$, to save
referring to the $\Sigma$, $M$ and $\Delta$ that formally define $O$
the following notational conventions shall be used:

\begin{itemize}
\item $S \in O$ is the {\it state existence predicate} asserting 
$S$ is a state of $O$. 
Formally, this is equivalent to $S \in \Sigma$.
\item $m : T \Rightarrow S' \in O@S$ is the {\it method existence predicate} 
asserting the existence
of method $m$ with return type $T$ in state $S$, which triggers a 
transition to state $S'$ when called (where both $S \in O$ and $S' \in O$). 
Formally, this is equivalent to $(S,m,T,S') \in \Delta$.
\item $m : T \Rightarrow \overline{S'} \in O@\overline{S}$ is the extension
of the method existence predicate to state sets, meaning that for all 
$S \in \overline{S}$ there exists a state $S'$ and type 
$T'$ where $(S,m,T',S') \in \Delta$.
$T$ is defined as 
$\bigsqcup_{S \in \overline{S}} \{ T' | (S,m,T',S') \in \Delta \}$
and $\overline{S'}$ is defined as $\{ S' | (S,m,T',S') \in \Delta \}$.
\item $O@\overline{S} \precsim O_2@\overline{S_2}$ is the extension of the
simulation relation to support state sets, and can be interpreted as
$\bigsqcup_{S \in \overline{S}}O@S \precsim \bigsqcup_{S_2 \in \overline{S_2}}O_2@S_2$.
\end{itemize}

\subsection{Object type isomorphism}

As object types in TS are based upon deterministic finite state machines,
there are often multiple ways to represent the same type. Object types
$O_1@S$ and $O_2@S$ are considered {\it isomorphic} 
(up to $\alpha$-conversion of state labels)
if they are both simulations of each other:
$O_1@\overline{S_1} \precsim O_2@S_2 \wedge O_2@\overline{S_2} \precsim O_1@\overline{S_1}$. 
The
{\it canonical} form amongst a set of isomorphic object types has a
{\it minimal} finite state machine.

\subsection{Effect types}

An ``effect type'' $T \gg T'$ describes how the type of a variable changes
in response to function application. In the TS language, as the values of
all types with the exception of objects are immutable, effects are
either identities ($T \gg T$) or object state changes 
($O@\overline{S_1} \gg O@\overline{S_2}$). As references cannot
be overwritten, we are guaranteed that the object instance cannot be replaced.
Therefore an effect type $O_1@\overline{S_1} \gg O_2@\overline{S_2}$ can
only be valid if $O_1 = O_2$.

\begin{figure}
\includegraphics[width=0.49\textwidth]{sm1.pdf}
\caption{\label{fig:sm1} A simple object protocol}
\end{figure}

State set transformations are restricted for semantic reasons also. Consider
the object protocol in \figref{fig:sm1}, which we will refer to as $O_1$.
An effect type of $O_1@B \gg O_1@A$ is impossible for this protocol, as there
is no sequence of method calls which would result in a transition from state
$B$ to state $A$. An effect type of $O_1@B \gg O_1@\{B,D\}$ is possible, 
as there is at least one sequence of method calls on an object in
state $B$ to both state $B$ and $D$.
An effect type $O_1@{B,D} \gg O_1@{B,C}$ which has more than one input state
is possible as there exists a sequence of method calls 
that would take an object in state $B$ to $C$ that would also
take an object in state $D$ to $B$ (specifically, a single method
call to $b$, which we can treat as having return type $\top = \boolt \sqcup \unitt$).

In the general case, an effect type concerning an object protocol $O$
of form $O@\overline{S} \gg O@\overline{S_2}$ is
valid if:

\begin{itemize}
\item Given a sequence of method calls that takes an object in state $S \in \overline{S}$
to state $S_2 \in \overline{S_2}$, the same sequence must also take an object
in any other $S' \in \overline{S}$ to a state $S_2' \in \overline{S_2}$.
\item All $S_2 \in \overline{S_2}$ are reachable by at least one sequence
of method calls from an object in a state $S \in \overline{S}$.
\end{itemize}

Checking the validity of an effect type is straightforward: given an
effect type $O@\overline{S_1} \gg O@\overline{S_2}$, we first compute
the intersection of all states $S \in \overline{S_1}$. In computing this
intersection, we can associate with each new state in the object protocol
representing the intersection to those states in the original protocol it
was derived from. Wherever one of these associated sets contains a state
$S \in \overline{S_2}$, all of the states in that set must be in 
$\overline{S_2}$. Finally, all end states $S \in \overline{S_2}$ must
exist in one of the associated sets.

An example of this is shown in \figref{fig:sm1} for the protocol $O_1$.
If the input of the effect type is $O_1@\{B,D\}$ then the only valid
outputs are either $O_1@\{B,D\}$ (no calls are made),
$O_1@\{B,C\}$ (exactly one call to $b$ is made), or
$O_1@\{B,C,D\}$ (the union of those two options). The effect type
$O_1@\{B,D\} \gg O_1@\{B\}$ would be correctly identified as invalid.

\subsection{Interpreting effect types with subtyping}

The typing judgement for a function call permits a passed parameter to
be a subtype of the input portion of the associated effect type.
Determining the type of the parameter after after the
function call, in particular where the parameter is an object, 
requires some thought to avoid losing type information unnecessarily.

Consider a function call $f(x)$ where \\
$f : (O_2@A \gg O_2@\{E,H\}) \rightarrow \top$ and
$x : O_1@A$, where $O_1$ and $O_2$
are the state machines from \figref{fig:principalex}.
It is clear that $O_1@A <: O_2@A$, therefore by definition any possible
sequence of method calls that $f$ could call on $x$ would be valid.
What should be the type of $x$ after the call, given the information that
the effect type gives?

A very naive but safe choice would be to choose $O_2@\{E,H\}$. However,
this will often result in an unacceptable loss of type information,
reducing the number of valid programs which can be typed within the system.
Based on the effect type,
we know that the function will interact with the $x$ using
one of the possible sequences of methods calls from $O_2@A$ to 
$O_2@E$ or $O_2@H$. There must exist some
$\overline{S_3}$ such that $\ot{O_1}{S_3} \precsim O_2@\{E,H\}$.
One possible solution would be to choose
$\overline{S_3} = \{ S | O@S \precsim \ot{O_2}{S_4} \}$. 
This is still liable to lose type information however --- given the object 
protocols from \figref{fig:principalex}, this would produce
$\overline{S_3} = \{ A, B, C, D \}$, as there are no possible method calls
on states $E$ or $H$ of $O_2$ (all object types trivially simulate the
empty object type $\{ S\{\} \}@S$). This chosen solution also ignores the
path taken to $O_2@E$ or $O_2@H$, and so may contain states
that are actually unreachable from $O_1@A$.

It is clear that our choice of $S_3$ must relate the set of possible method
call sequences between $O_2@A$ and $O_2@\{E,H\}$. For this we
define a relation between pairs of object types
$(O_1@\overline{S}, O_2@\overline{S_2} \lesssim 
(O_1@\overline{S_3}, O_2@\overline{S_4})$, which we call the
{\it path relation}, which defines equivalent paths through the
respective object protocols. The definition of the path relation
is given in \figref{fig:simreach}. 

\begin{figure}

\[
\begin{array}{c}

\infer[\lesssim\textsc{-refl}]
  {(O_1@\overline{S_1}, O_2@\overline{S_2}) \lesssim (O_1@\overline{S_1}, O_2@\overline{S_2})}
  {O_1@\overline{S_1} \precsim O_2@\overline{S_2}}
\\\\
\infer[\lesssim\textsc{-adj}]
  {(O_1@\overline{S_1}, O_2@\overline{S_2}) \lesssim (O_1@\overline{S_3}, O_2@\overline{S_4})}
  {
    \begin{array}{cc}
    \multicolumn{2}{c}{O_1@\overline{S_1} \precsim O_2@\overline{S_2}}
    \\
    m : T_i \Rightarrow \overline{S_4} \in O_2@\overline{S_2}
    &
    m : T_i' \Rightarrow \overline{S_3} \in O_1@\overline{S_1}
    \end{array}
  }

\\\\
\infer[\lesssim\textsc{-trans}]
  {
  (O_1@\overline{S_1}, O_2@\overline{S_2}) \lesssim (O_1@\overline{S_5}, O_2@\overline{S_6})
  }
  {
  \begin{array}{c}
  (O_1@\overline{S_1}, O_2@\overline{S_2}) \lesssim (O_1@\overline{S_3}, O_2@\overline{S_4})
  \\
  (O_1@\overline{S_3}, O_2@\overline{S_4}) \lesssim (O_1@\overline{S_5}, O_2@\overline{S_6})
  \end{array}
  }
\\\\
\infer[\lesssim\textsc{-branch}]
	{
	(\ot{O_1}{S_1}, \ot{O_2}{S_2}) \lesssim (\ot{O_1}{S_7}, \ot{O_2}{S_8})
	}
	{
	\begin{array}{cc}
	\multicolumn{2}{c}{
	(\ot{O_1}{S_1}, \ot{O_2}{S_2}) \lesssim (\ot{O_1}{S_3}, \ot{O_2}{S_4})
	}
	\\
	\multicolumn{2}{c}{
	(\ot{O_1}{S_1}, \ot{O_2}{S_2}) \lesssim (\ot{O_1}{S_5}, \ot{O_2}{S_6})
	}
	\\
	\overline{S_7} = \overline{S_3} \cup \overline{S_5}
	&
	\overline{S_8} = \overline{S_4} \cup \overline{S_6}
	\end{array}
	}
	
\end{array}
\]
\caption{\label{fig:simreach} Definition of the simulation predecessor relation}
\end{figure}

The type system of TS defines a partial function named {\it remap}, 
formalised in \figref{fig:remaprules}, to choose the type of a passed parameter
after a function call. For object types, the path relation is used to choose
the correct state set. For our example, the type of $x$ after the call
$f(x)$ will therefore be $O_1@A$, as
$(O_1@A, O_2@A) \lesssim (O_1@A, O_2@{E,H})$.

\begin{figure}
\ottdefnremap

\caption{\label{fig:remaprules} Definition of remap}
\end{figure}

\subsection{Principal typings \& types}

A typing of the term $t$ is the triple $\tau = (\Gamma,T,\Gamma')$ such that
$\typerule{\Gamma}{t}{T}{\Gamma'}$. Typings can be ordered using the subtyping
relation. Given two typings $\tau_1 = (\Gamma_1,T_1,\Gamma_1')$ and
$\tau_2 = (\Gamma_2,T_2,\Gamma_2')$ of $t$ we say that $\tau_2$ is 
{\it stronger} than $\tau_1$, written $\tau_1 \leq \tau_2$, if:

\begin{enumerate}
\item $\Gamma_2$ contains fewer variables: 
      $dom(\Gamma_1) \supset dom(\Gamma_2)$
\item If $dom(\Gamma_1) = dom(\Gamma_2)$, 
	  then the variables of $\Gamma_2$ have less specific types: \\
      $\forall x \in dom(\Gamma_1), \Gamma_1(x) <: \Gamma_2(x)$
\item If $\Gamma_1 = \Gamma_2$, then $\Gamma_2'$ contains more variables:
      $dom(\Gamma_1') \subset dom(\Gamma_2)$
\item If $dom(\Gamma_1') = dom(\Gamma_2')$, then $\Gamma_2'$ contains
      more specific types: \\
      $\forall x \in dom(\Gamma_1), \Gamma_2'(x) <: \Gamma_1'(x)$
\item If $\Gamma_1' = \Gamma_2'$, then $T_2 <: T_1$.
\end{enumerate}

The relation is a partial order. The principal typing of $t$ is the strongest 
typing of $t$, if it exists: $\forall \tau' \exists \tau . \tau' \leq \tau$.
Given such a principal typing
$\tau = (\Gamma,T,\Gamma')$, the type $T$ 
is referred to as the {\it principal type} of the term $t$.
The type of a variable $x \in dom(\Gamma)$ shall also be referred to as a 
{\it principal variable input type} of $x$ in $t$. Similarly, the type
of $x \in dom(\Gamma')$ shall be referred to as the
{\it principal variable output type} of $x$ in $t$.

\begin{figure}
\includegraphics[width=0.49\textwidth]{principal.pdf}
\caption{\label{fig:principalex} Valid types of function $f$}
\end{figure}

Given a term $t$ which interacts with an object variable $o$, the
principal variable input type of $o$ is an object type which would permit
all sequences of method calls to $o$ that could occur in $t$, and no more.
Equivalently, the language accepted by the object type $o$ is the smallest 
possible, while the return types of the methods of the states of $o$
are as general as possible.

Consider the body term of example function $f$ shown in 
\figref{fig:principalex}. It is clear from the usage
of $y$ that its principal variable input type must be $\boolt$ as demanded by the 
type judgement of an if-then-else statement, while $x$ is an object.
We could ascribe any of the object types $O_1@A$, $O_2@A$ and $O_3@A$ to the 
variable $x$, and after evaluation the object types would be $O_1@A$, $O_2@\{E,H\}$
and $O_2@F$ respectively.
$O_1@A$ is not a principal variable input type for $x$ as it will permit many more 
sequences of method calls 
than strictly required, and also has a more
specific return type for the method $n$ than is necessary. $O_2@A$ 
is the principal variable input type for $x$, as is the type $O_3@A$, which is
isomorphic. It is arguable that $O_3@A$ is a preferable solution to
$O_2@A$, as it has a minimal object protocol. However as they are isomorphic
it is of little consequence which is chosen, and if the latter is preferable
for display to a user it can be computed on demand.

% It is possible for a principal effect type to have more than
% one state in the state set of the input (left) object type. It is
% always possible to restructure such an object type to have a single initial
% state. It is not, however, possible to have both a single input state and
% single output state for a state machine accepting an arbitrary language --- 
% consider the language accepted by the regular expression $m^* | n^*$. It is 
% necessary for a state machine which accepts this language, and only this 
% language, to
% have at least three exit states. In general, it is more intuitive to have
% a single input state in the effect type but this is not required for a
% type to be considered principal.

The principal typing of the body of function $f$ is \\ 
$(\{x \mapsto O_3@A, y \mapsto \boolt \}, \top, \{ x \mapsto O_3@F, y \mapsto \boolt \})$.
From this, it follows that the principal type of $f$ itself is \\
$(O_3@A \gg O_3@F, \boolt \gg \boolt) \rightarrow \top$.

Unfortunately, principal typings do not exist for all typeable terms.
Consider the term $t = $ {\tt f(x)}. \\
Let $\Gamma_1 = \{f \mapsto (\boolt \gg \boolt) \rightarrow \top, x \mapsto \boolt \}$. \\
Let $\Gamma_2 = \{f \mapsto (\unitt \gg \unitt) \rightarrow \top, x \mapsto \unitt \}$. \\
It follows that $\tau_1 = (\Gamma_1, \top, \Gamma_1)$
and $\tau_2 = (\Gamma_2, \top, \Gamma_2)$ are typings of $t$. 

Assume a principal typing $\tau_3 = (\Gamma_3, T_3, \Gamma_3')$ exists for $t$.
Therefore, $\tau_1 \leq \tau_3$ and $\tau_2 \leq \tau_3$.

The domains of $\Gamma_1$ and $\Gamma_2$ are minimal, as the term $t$
cannot be typed without both $f$ and $x$ in the input context by rule \tfunc.
It follows that we must have
$\Gamma_1(f) <: \Gamma_3(f)$ and $\Gamma_2(f) <: \Gamma_3(f)$. 
Let $T' = \Gamma_3(f)$. For $\tau_3$ to be a typing, it must be the case that
$T' = (U \gg V) \rightarrow W$ by rule \tfunc. By rule \subfn, it follows that
$U <: \boolt$ and $U <: \unitt$. Therefore, $U <: \boolt \sqcap \unitt$.
The type $\boolt \sqcap \unitt$ is not defined.
Therefore, $\tau_3$ cannot exist.

Principal typings do, however, exist for all
terms with no free variables that are used as functions. This is proven
in \thmref{thm:principal} in \appref{app:principal}.

\section{Type inference for TS0}

The full syntax for object types is verbose and difficult for a user to parse.
Having to write out object types in full would therefore obfuscate the
intent of the code, particularly when there is a
strong correlation between the code and the principal object types of the
variables it interacts with. In a language such as TS where nominal typing
is not used, typestate inference is essential.

The main source of avoidable verbosity in TS is in the
type annotations on function literals: one would hope that knowledge of
the function body would be sufficient to determine the effect types for
each parameter passed to the function. Indeed, if a principal typing can
be derived for the function body, then a principal typing for the function
literal can be directly constructed from this as shown in
\thmref{thm:principal}. 

We therefore desire a general type inference strategy that can 
deduce a principal typing for a term $t$, if one exists. Our approach to type 
inference is inspired by \cite{Pottier2005}, using separate
constraint generation and constraint solving phases 
to deduce the principal typing of the root term.

The constraint grammar is shown in \figref{fig:congrammar}.

\begin{figure}
\ottgrammartabular{
\ottC\ottinterrule
\ottctxc\ottinterrule
\otttyc\ottinterrule
\otttinf\ottinterrule
\ottoinf\ottinterrule
\ottsinf\ottinterrule
}
\caption{\label{fig:congrammar} Constraint grammar}
\end{figure}

\begin{figure}
\[
\begin{array}{ll}

% unit value
\inferlhs{\unitv} \coloneqq \alpha = \unitt \cand \gamma' = \gamma
\\\\

% true value
\inferlhs{\truev} \coloneqq \alpha = \boolt \cand \gamma' = \gamma 
\\\\

% false value
\inferlhs{\falsev} \coloneqq \alpha = \boolt \cand \gamma' = \gamma 
\\\\

% object value
\inferlhs{[ \overline{S_i \{ \overline{ m_{ij} = (v_{ij}, S_{ij}) } \} }]@\overline{S}}
\coloneqq \\
\exists \alpha_o, \alpha_s, \overline{\alpha_{ij}}, \gamma_{\emptyset} . \\
\gamma_{\emptyset} = \emptyset
\cand
\alpha = \alpha_o@\alpha_s
\cand
\overline{\inferrule{\gamma_{\emptyset}}{v_{ij}}{\alpha_{ij}}{\gamma_{\emptyset}}}
\cand
\\
\gamma = \gamma'
\cand
\alpha_o @ \alpha_s = \{ \overline{ S_i \{ \overline{ m_{ij} : \alpha_{ij} >> S_{ij} } \} }\} @ \overline{S}
\\\\

% function value
\inferlhs{\lambda ( \overline{x_i : T_i \gg T_i'} ) . t} \coloneqq \\
\exists \gamma_r, \gamma_{in}, \gamma_{out}, \overline{\alpha_i, \alpha_i'}, \alpha_r . \\
\alpha = (\overline{\alpha_i \gg \alpha_i'}) \rightarrow \alpha_r
\cand
\gamma = \gamma'
\cand
\gamma_r = \emptyset
\cand \\
\gamma_{in} = \gamma_r, \overline{x_i : \alpha_i}
\cand
\overline{x_i : \alpha_i' \in \gamma_{out}}
\cand
\\
\inferrule{\gamma_{in}}{t}{\alpha_r}{\gamma_{out}}
\\
\cand
\overline{T_i <: \alpha_i}
\cand
\overline{\alpha_i' <: T_i'}
\\\\

% let binding
\inferlhs{\lett{x}{t'}{t}} \coloneqq \\
\exists \gamma_v, \gamma_{in}, \gamma_{out}, \alpha' . \\
\gamma_{in} = \gamma_v, x : \alpha'
\cand
\gamma' = \gamma_{out} - \{ x \}
\cand \\
\inferrule{\gamma}{t'}{\alpha'}{\gamma_v}
\cand
\inferrule{\gamma_{in}}{t}{\alpha}{\gamma_{out}}
\\\\

% sequence
\inferlhs{t ; t'} \coloneqq \\
\exists \gamma'', \alpha' . \\
\inferrule{\gamma}{t}{\alpha'}{\gamma''}
\cand
\inferrule{\gamma''}{t'}{\alpha}{\gamma'}
\\\\

% function call
\inferlhs{x ( \overline{x_i} )} \coloneqq \\
\exists \overline{\alpha_i}, \overline{\alpha_i'}, \overline{\alpha_i''} . \\
\overline{x_i : \alpha_i \in \gamma}
\cand 
x : ( \overline{\alpha_i' \gg \alpha_i''} ) \rightarrow \alpha \in \gamma
\cand
\\
\gamma' = \gamma [ \overline{x_i \mapsto \remapapp{\alpha_i}{\alpha_i'}{\alpha_i''} } ]
\\\\

% method call
\inferlhs{x.m} \coloneqq \\
\exists \alpha_o, \alpha_s . \\
x : \alpha_o@\alpha_s \in \gamma
\cand \\
\gamma' = \gamma[ x \mapsto \remapapp{\alpha_o@\alpha_s}{O@S}{O@S'} ]
\\
\mathbf{where}\; O = \{ S \{ m : \alpha \Rightarrow S' \} S' \{ \} \}
\\\\

% if-then-else
\inferlhs{\ift{t_c}{t_t}{t_f}} \coloneqq \\
\exists \alpha_c, \alpha_t, \alpha_f, \gamma_c, \gamma_t, \gamma_f . \\
\inferrule{\gamma}{t_c}{\alpha_c}{\gamma_c}
\cand
\inferrule{\gamma_c}{t_t}{\alpha_t}{\gamma_t}
\cand 
\\
\inferrule{\gamma_c}{t_f}{\alpha_f}{\gamma_f}
\cand
\alpha_c = \boolt
\cand
\\
\alpha = \alpha_t \sqcupplus \alpha_f
\cand
\gamma' = \gamma_t \sqcup \gamma_f
\\\\

\end{array}
\]
\caption{\label{fig:constraintgen} Constraint generation}
\end{figure}

There are three categories of constraints:

\begin{itemize}
\item {\bf Context constraints} --- these define relationships between contexts.
It is important that type changes be correctly observed by the inference
approach and that context constraints expressed in terms of equality, extension,
modification and removal exactly mirror the typing judgements. 
Extension, replacement and removal constraints modify the solution of
another context variable. Following these context variable dependencies,
ultimately every context variable depends upon a {\it root} variable which
is either of form $\gamma = \emptyset$ or $\free{\gamma}$. The root
context is {\it free} when it is the input context to the top-level term being
processed, while
the root is {\it empty} when it is the input context for a function body term.
A free context can be arbitrarily extended with new variables, while an
empty context cannot --- this difference allows the detection of unbound
variable usage within function bodies and the collection of free variables
in the root term.

Additionally, we have {\it variable usage constraints} of form 
$x : \tinf \in \gamma$, which are generated for each location in the
program where a variable is used and what type that usage implies. These
are used to generate additional type variable
constraints by matching the asserted type $\tinf$ with what is known
about the type of $x$ in $\gamma$.

\item {\bf Type expressions constraints} --- these express 
relationships between types. Either two types are equal ($\tinf = \tinf'$),
one type is a subtype of another ($\tinf <: \tinf'$) or one type
is the join of two others ($\tinf \sqcup \tinf'$). As a special case of
the latter, if it is known that the two types are derived from
interactions with the same value, this is written as $\tinf \veebar \tinf'$.
This additional information is relevant when solving object type constraints
in particular, and is discussed later.
\end{itemize}

Type variables can appear at any position within a type's structure, as shown
in the grammar for $\tinf$. Objects are treated as a special case, where
we use variables as placeholders for the object definition and state parts.
The states and transitions of the object structure are determined at a later
stage in the type inference process.

A constraint generation expression $\inferlhs{t}$, which relates the term
to an input context variable, a type variable and an output context variable, 
is expanded using the rules shown in \figref{fig:constraintgen}.
The constraint generation process for a root term is defined
by the function $gen(t) = \exists \gamma, \gamma', \alpha. \free{\gamma} \cand \inferlhs{t}$.

The constraint generation rules correspond to the typing judgements for 
well-typed terms as one would expect:

\begin{itemize}
\item All value terms produce a $\gamma = \gamma'$ constraint as values do
not change the context. Additionally, a type variable constraint of form
$\alpha = \tinf$ is generated where $\tinf$ is of the appropriate type to 
match the value. In the case of functions or object values, this type will
contain additional type variables for parameters and return values, with
the intention that these be solved to validate user type annotations.
\item The context variable $\gamma_{in}$ used as the input context for
function bodies has an empty root $\gamma_r$. This allows for the detection of 
used unbound variables within
the body term. The domain of the input context is strictly composed of the 
parameters, preventing implicit binding, in order to match the properties
of the typing judgement for functions.
\item Let-bind terms generates a new context variable $\gamma_v$ for the
output context of the value term. This is extended by $\gamma_{in}$, the
input context for the body term, with variable $x$ of the type inferred
for the value. The output context $\gamma'$ of the whole let-bind term removes
$x$ from the output context $\gamma_{out}$ of the body term.
\item Sequencing terms relate the output of the left term to the input of the
right term through a new context variable $\gamma''$. The type variable
$\alpha'$ is generated to infer the type of the left term, though this is not needed beyond confirming that it does in fact have a type.
\item Function call terms generate context variable constraints to relate the
usage of the variables to whatever information has been inferred about the
parameter types of the function. All variables $\overline{x_i}$ used as 
parameters in the function call are replaced in the output context with
new type bindings to $\overline{\alpha_i'}$, which represents the effect
of the function.
\item Method call terms generate type variables to capture that $x$ must
be an object, that the method $m$ must exist in the current state $\alpha_s$
and that after the method call $x$ must be in the new state $\alpha_s'$.
\item If-then-else terms relate the context variables used for the
condition, true branch and false branch as expected. It is asserted that the
type of the condition must be a boolean. The output context
variable $\gamma'$ is expressed as the join of the outputs for the true
and false branches.
\end{itemize}

\subsection{Constraint solving}

Constraint solving is performed in phases. First, generated context constraints
for a term $t$ are solved, which determines the contents of each context associated to
each context variable in the typing derivation of $t$, and produces additional
type equality constraints (of form $\mathbb{T} = \mathbb{T}'$) based on
observed usages of variables. If a variable either used in a context where
it is unbound (the variable is {\it free} in $t$) or it is rebound
(a subterm within $t$ is of form $let x = ... in t'$ where a subterm of $t'$
is also of form $let x = ... in t''$), then no principal typing exists and
the phase reports the offending variable.

Then, the set of type constraints is solved, which determines a lower and
upper bound for each type variable, if such bounds can be determined.
Additionally, if the constraints lead to a contradiction (i.e. demanding the
existence of an invalid type like $\boolt \sqcup \unitt$) then no solution
will be reported.

\subsection{Context constraint solving}

Solving context constraints involves {\it normalising} the constraints.
A {\it normalised} constraint is one in which
context variable has a single 
defining constraint of form $\gamma = \emptyset$, $\free{\gamma}$ or
$\gamma = \gamma', \overline{x_i : \tinf_i}$, where $\gamma'$ is
either empty or free. A context $\Gamma$ for type checking can be easily
constructed from constraints in this form, as once the type variable
constraints are solved we can say $\Gamma = \overline{x_i : T_i}$ for
every $\gamma = \gamma', \overline{x_i : \tinf_i}$ where $T_i$ is the
solved form of $\tinf_i$, or $\Gamma = \emptyset$ for every $\free{\gamma}$
or $\gamma = \emptyset$.

We say that a constraint $C$ is {\it normalisable} if, by
applying the rules in \figref{fig:contextsolve}, it can be transformed to
a constraint $C'$ which is normalised, or the rules produce $\mathbf{bound}\:x$
or $\mathbf{unbound}\:x$ for some variable $x$.

\begin{figure}

\begin{center}
\begin{tabular}{c}
	\infer[\textsc{c\_eq}]
	{\gamma = \gamma'', \overline{x_i : \tinf_i} \cand \gamma' = \gamma'', \overline{x_i : \tinf_i}}
	{\gamma = \gamma' \cand \gamma' = \gamma'', \overline{x_i : \tinf_i}}
\\\\
	\infer[\textsc{c\_eq\_2}]
	{\gamma = \gamma', \emptyset}
	{C \cand \gamma = \gamma' & \free{\gamma'} \in C \vee \gamma' = \emptyset \in C}
\\\\
	\infer[\textsc{c\_rem}]
	{
	\gamma = \gamma'', \overline{x_i : \tinf_i} \cand \gamma' = \gamma'', \overline{x_i : \tinf_i}, x : \tinf
	}
	{
	\gamma = \gamma' - \{x\} \cand \gamma' = \gamma'', \overline{x_i : \tinf_i}, x : \tinf
	}
\\\\
	\infer[\textsc{c\_ext}]
	{\gamma = \gamma'', \overline{x_i : \tinf_i}, \overline{y_j : \tinf_j} \cand \gamma' = \gamma'', \overline{x_i : \tinf_i}}
	{
		\gamma = \gamma', \overline{y_j : \tinf_j} \cand \gamma' = \gamma'', \overline{x_i : \tinf_i}
		& \overline{y_j} \cap \overline{x_i} = \emptyset
	}
\\\\
	\infer[\textsc{c\_ext\_2}]
	{\mathbf{bound}\:x}
	{
		\gamma = \gamma', \overline{y_j : \tinf_j}, x : \tinf \cand \gamma' = \gamma'', \overline{x_i : \tinf_i}
		& x \in \overline{x_i}
	}
\\\\
	\infer[\textsc{c\_rep}]
	{\gamma = \gamma'', \overline{x_i : \tinf_i}, x : \tinf \cand
	\gamma' = \gamma'', \overline{x_i : \tinf_i}, x : \tinf'}
	{\gamma = \gamma'[x \mapsto \tinf] \cand
	\gamma' = \gamma'', \overline{x_i : \tinf_i}, x : \tinf'}
\\\\
	\infer[\textsc{c\_rep\_2}]
	{
	\begin{array}{c}
	\exists \alpha . 
	\gamma = \gamma'[x \mapsto \tinf] \cand
	\gamma' = \gamma'', \overline{x_i : \tinf_i} \cand
	\\
	x : \alpha \in \gamma''
	\end{array}
	}
	{
	\begin{array}{c}
	\begin{array}{cc}
	x \notin \overline{x_i}
	&
	\fresh{\alpha}
	\end{array}
	\\
	\gamma = \gamma'[x \mapsto \tinf] \cand
	\gamma' = \gamma'', \overline{x_i : \tinf_i}
	\end{array}
	}
\\\\
	\infer[\textsc{crep\_3}]
	{C \cand \gamma = \gamma'[x \mapsto \tinf] \cand 
	 x : \alpha \in \gamma'}
	{
	C \cand \gamma = \gamma'[x \mapsto \tinf]
	&
	\free{\gamma'} \in C \vee \gamma' = \emptyset \in C
	}
\\\\
	\infer[\textsc{cvar\_1}]
	{\exists \gamma' . \free{\gamma'} \cand \gamma = \gamma', x : \tinf}
	{\free{\gamma} \cand x : \tinf \in \gamma}
\\\\
	\infer[\textsc{cvar\_2}]
	{\mathbf{unbound}\:x}
	{\gamma = \emptyset \cand x : \tinf \in \gamma}
\\\\
	\infer[\textsc{cvar\_3}]
	{\gamma = \gamma', \overline{x_i : \tinf_i} \cand x : \tinf \in \gamma'}
	{\gamma = \gamma', \overline{x_i : \tinf_i} \cand x : \tinf \in \gamma
	&
	x \notin \overline{x_i}
	}
\\\\
\infer[\textsc{t\_var}]
	{
	\tinf' <: \tinf \cand 
	\gamma = \gamma', \overline{x_i : \tinf_i}, x : \tinf'
	}
	{
	x : \tinf \in \gamma \cand 
	\gamma = \gamma', \overline{x_i : \tinf_i}, x : \tinf'}
\\\\
	\infer[\textsc{c\_join}]
	{
	\begin{array}{c}
	\gamma = \overline{x_i : \tinf_i''} \cand 
	\gamma' = \gamma_r, \overline{x_i : \tinf_i} \cand 
	\\
	\gamma'' = \gamma_r, \overline{x_i : \tinf_i'} \cand
	\overline{\tinf_i'' = \tinf_i \sqcup \tinf_i'}
	\end{array}
	}
	{
	\begin{array}{c}
	\gamma = \gamma' \sqcup \gamma'' \cand 
	\gamma' = \gamma_r, \overline{x_i : \tinf_i} \cand 
	\\
	\gamma'' = \gamma_r, \overline{x_i : \tinf_i'}
	\end{array}
	}
\\\\
	\infer[\textsc{cerr\_1}]
	{\mathbf{unbound}\:x}
	{C \cand \mathbf{unbound}\:x}
\\\\
	\infer[\textsc{cerr\_2}]
	{\mathbf{bound}\:x}
	{C \cand \mathbf{bound}\:x}
\end{tabular}
\end{center}
\caption{\label{fig:contextsolve} Context normalisation}
\end{figure}

The context normalisation rules do the following:

\begin{itemize}
\item $\textsc{c\_eq}$ --- Where $\gamma$ is directly equivalent
to $\gamma'$, which is defined in terms of extension of
$\gamma''$, rewrite the constraints such that
$\gamma$ directly copies the definition of $\gamma'$.
\item $\textsc{c\_eq\_2}$ --- Where $\gamma$ is directly equivalent
to $\gamma'$, which is defined as either $\free{\gamma}$ or 
$\gamma = \emptyset$, $\gamma'$ is defined to be an empty extension of 
$\gamma'$.

\item $\textsc{c\_rem}$ --- Where $\gamma$ removes a variable $x$ from $\gamma'$,
which is defined in terms of extension of $\gamma''$ that is known to have
$x$ in its domain, rewrite the
constraints such that $\gamma$ copies the definition $\gamma''$ with
the variable $x$ removed from the extension. There is no need for an
error-producing variant of \textsc{c\_rem}, where the variable $x$ is missing, 
as context removal constraints are always generated in a pair with a context 
extension constraint for let binding.

\item $\textsc{c\_ext}$ --- Where $\gamma$ extends $\gamma'$ with
a variable set $\overline{y_j}$, and $\gamma'$ is defined in terms of extension of
$\gamma''$ with a disjoint set of variables in its extension set, rewrite the
constraint such that $\gamma$'s extension set includes both the $y_j$
definitions and $x_j$ definitions.

\item $\textsc{c\_ext}_2$ --- Where $\gamma$ extends $\gamma'$ with
a new variable $x$, and $\gamma'$ is defined in terms of extension of
some $\gamma''$ and the extension set already contains $x$, this
represents an attempt to redeclare $x$. As such, generate an error
$\mathbf{bound}\:x$, terminating the constraint solving process.

\item $\textsc{c\_rep}$ --- where $\gamma$ replaces the type of some
variable $x$ in $\gamma'$, where $\gamma$ is defined in terms of extension
of $\gamma''$ and $x$ is in the extension set, rewrite the constraints
such that $\gamma$ copies the extension set of $\gamma'$ with $x$
replaced as specified.

\item $\textsc{c\_rep}_2$ --- where $\gamma$ replaces variable $x$ in
$\gamma'$ which is defined in terms of extension of $\gamma''$
which is free and $x$ is not in the extension set, $x$ is a
free variable in the term being processed. To introduce $x$ in such a way that
it will be included in all contexts, a variable usage constraint
$x : \alpha \in \gamma''$ is introduced, with the intention that this be
solved by $c\_var\_1$ or $c\_var\_2$ first before the replacement can be
solved using $c\_rep\_1$.

\item $\textsc{crep}_3$ --- this performs the same function as
$c\_rep\_2$, but for the case where $\gamma$ is directly defined as
a replacement on a free or empty context variable $\gamma'$.

\item $\textsc{c\_var\_1}$ --- where $x$ is asserted to exist in a context
variable $\gamma$, which is defined as $\free{\gamma}$, the definition
of $\gamma$ is replaced with one which extends a new free context variable
$\gamma'$ with the variable $x$. This is intended to also have the effect
that all other context variables which are defined as extensions of 
$\gamma$ will have to be updated using \textsc{c\_ext}, or an error
generated by \textsc{c\_ext} if they already contain $x$.

\item $\textsc{c\_var\_2}$ --- where $x$ is asserted to exist in a
context variable $\gamma$, which is defined as $\gamma = \emptyset$, this
represents the attempt to use an unbound variable in a context which does
not permit free variables (such as in the body of a function). As such,
an $\mathbf{unbound}\:x$ error is generated.

\item $\textsc{c\_var\_3}$ --- where $x$ is asserted to exist
in a context variable $\gamma$, which is defined in terms of
extension of $\gamma'$ which does not include $x$, the assertion
can be rewritten as an assertion that $x$ must exist within $\gamma'$.
This is intended to propagate to a root context variable and solved
by \textsc{c\_var\_1} or \textsc{c\_var\_2}.

\item $\textsc{c\_join}$ --- where a context variable is defined as the
join of two other context variables $\gamma'$ and $\gamma''$, which are in turn defined as extensions
of the same context variable $\gamma_r$, and which contain the same variables,
the join can be solved by generating a new set of type variables, one for
each $x_i$, defined as the join of the types known for $x_i$ in $\gamma'$
and $\gamma''$.
\end{itemize}

The rules are repeatedly applied to any matching sets of constraints
until no further rewriting is possible, producing either an error
or a set of context constraints which are fully normalised, and
can be converted into contexts for type checking easily.

Given an arbitrary term $t$, the context constraints generated by $t$
are normalisable (see \appref{app:ctx_norm}).
This is less general than stating that the context constraint solving rules
can solve any conjunction of context constraints, but is sufficient for
the purposes of this language.

\subsection{Additional type variable constraint solving}

During context constraint solving, a number of additional type variable
constraints are generated by rule \textsc{t\_var} and \textsc{c\_join}.
These, in addition to the original type variable constraints generated
directly from the term under consideration, form the constraint set that
is to be solved by the type variable constraint solving phase.

\subsection{Type variable constraint solving}

Solving a set of type variable constraints consists of demonstrating that
there exists at least one substitution $\sigma$ for all type variables that 
turns all constraints into tautologies.

For instance, the constraint
$\alpha = \boolt \cand \alpha' <: \alpha$ has exactly one type variable 
substitution that provides a valid solution, which is 
$\sigma = \{ (\alpha, \boolt), (\alpha', \boolt) \}$. 

A constraint may have no solution, such as the constraint 
$\unitt <: \alpha \cand \alpha <: \boolt$, where no type can satisfy the upper
and lower bounds specified on $\alpha$.

A constraint may also have an infinite number of solutions, such as 
$\alpha <: \{ S \{ m : \alpha' \Rightarrow S' \} S' \{\} \}$, where
$\alpha'$ can be any valid type and $\alpha$ can be any object type which 
allows at least one call to the method $m$, which must return the type 
$\alpha'$.

The goal of the type constraint solver is to find the most general substitution
such that all other possible substitutions are {\it refinements} of this base
substitution, written $\sigma \sqsubset \sigma'$. This means that 
$dom(\sigma) \subseteq dom(\sigma')$ and that 
$\forall x \in dom(\sigma)$ . $\sigma'(x) <: \sigma(x)$.

The type system of TS1 does not support type variables, therefore any
set of constraints for which a concrete lower type bound cannot be found 
for every type variable has no solution.

The basic types $\boolt$, $\unitt$ and $\funt{T_i}{U_i}{V}$ exhibit 
{\it structural subtyping}. However object types do not. If we treat object 
type expressions as atoms,
then a standard constraint solver which supports structural subtyping such as 
\cite{Simonet2003} can be used. This solver will find solutions for all of the 
variables that concern structural types, and leave a set of constraints between 
object type variables which we must solve through some other mechanism. 
This is the approach taken for the type constraints for TS1, which separates 
the task of {\it object constraint solving} from the main type constraint 
solving phase.

\subsection{Object constraint solving}

This phase of the algorithm is only concerned with constraints of the form
listed in \figref{fig:objconstraints}. The two classes of variable, object
and state variables, have no particular significance other than clarifying
their roles during solving.

The output from the structural subtyping constraint solver should contain
a set of equality and subtyping constraints that concern object types.
TODO: describe normalisation of object constraints.

Given a conjunction of such normalised
constraints $C_\omega$, solving proceeds by application of the rules in
\figref{fig:objsolving}.

\begin{itemize}

\item $\textsc{=-solve}$ ``connects'' two existing solutions in order to
produce a single solution, which is as minimal as possible. $connect()$ is
a variant of state machine union where the initial and final states are
unknown. Some examples are shown in \figref{fig:connect_ex}

\end{itemize}

\begin{figure}
\[
\begin{array}{ll}
\omega = \partialo{}{} 
	& \text{partial object solution}
	\\
\omega = \fixedo{}{}
	& \text{fixed object solution} 
	\\
\sigma = \mathbf{unknown}
	& \text{undefined state set}
	\\
\sigma = \overline{S} 
	& \text{state set solution} 
	\\
\os{1}{1} = \os{2}{2} 
	& \text{equality} 
	\\
\os{1}{1} <: \os{2}{2} 
	& \text{subtyping} 
	\\
\os{1}{1} = \\
\:\:\remapapp{\os{1}{2}}{\os{2}{3}}{\os{2}{4}} 
	& \text{remap definition}
	\\
\os{1}{1} = \os{2}{2} \sqcup \os{3}{3}
	& \text{outer join}
	\\
\os{1}{1} = \os{1}{2} \veebar \os{1}{3}
	& \text{inner join}
\end{array}
\]
\caption{\label{fig:objconstraints} Normalised object variable constraints}
\end{figure}

\begin{figure*}
\includegraphics[width=\textwidth]{connect_ex1.pdf}
\caption{\label{fig:connect_ex} Examples of connecting solutions}
\end{figure*}

% \begin{figure}
% \begin{center}
% \begin{tabular}{c}
% \infer[\textsc{eq\_norm}]
% 	{
% 	\substo{\omega@\sigma}{\alpha}{C}
% 	}
% 	{
% 	C \cand \alpha = \omega@\sigma
% 	}
% \\\\
% \infer[\textsc{sub\_norm\_1}]
% 	{
% 	\substo{\omega_2@\sigma_2}{\alpha}{C}
% 	}
% 	{
% 	C \cand \alpha <: \omega@\sigma
% 	&
% 	\fresh{\omega_2}
% 	&
% 	\fresh{\sigma_2}
% 	}
% \\\\
% \infer[\textsc{sub\_norm\_2}]
% 	{
% 	\substo{\omega_2@\sigma_2}{\alpha}{C}
% 	}
% 	{
% 	C \cand \omega@\sigma <: \alpha
% 	&
% 	\fresh{\omega_2}
% 	&
% 	\fresh{\sigma_2}
% 	}
% \\\\
% \infer[\textsc{join\_}]
% \end{tabular}
% \end{center}
% \caption{\label{fig:objnorm} Object constraint normalisation rules}
% \end{figure}

\begin{figure*}

\begin{center}
\begin{tabular}{cc}

\infer[\textsc{$=$-solve}]
{
	\substo{\omega}{\omega_1}{
	\substo{\omega}{\omega_2}{
	\substo{\sigma}{\sigma_1}{
	\substo{\sigma}{\sigma_2}{C}}}} \cand
	\omega = \Omega \cand
	\sigma = \Sigma
}
{
	\begin{array}{c}
	C \cand 
	\os{1}{1} = \os{2}{2} \cand
	\omega_1 = \Omega_1 \cand
	\omega_2 = \Omega_2 \cand
	\sigma_1 = \Sigma_1 \cand
	\sigma_2 = \Sigma_2
	\\
	\sigma = min(\sigma_1, \sigma_2) \:\:\:
	\omega = min(\omega_1, \omega_2) 
	\\
	(\Omega, \Sigma) = \mathbf{connect}(\Omega_1, \Sigma_1, \Omega_2, \Sigma_2)
	\end{array}
}

\\
\\

\infer[\textsc{remap-solve}]
{
	C \cand
	\omega_1 = \partialo{}{'} \cand
	\sigma_1 = \overline{S}_{out} \cand
	\sigma_2 = \overline{S}_{in}
}
{
	\begin{array}{c}
	C \cand
	\os{1}{1} = \remapapp{\os{1}{2}}{\os{2}{3}}{\os{2}{4}} \cand
	\omega_1 = \partialo{1}{} \cand
	\sigma_1 = \Sigma_1 \cand
	\sigma_2 = \Sigma_2
	\\
		\begin{array}{ccc}
		\omega_2 = \fixedo{2}{} \in C
		&
		\sigma_3 = \overline{S}_3 \in C
		&
		\sigma_4 = \overline{S}_4 \in C
		\end{array}
	\\
	(\mathbb{S}, \overline{S}_{in}, E) = \mathbf{refine}(\mathbb{S}_1, \Sigma_2, \mathbb{S}_2, \overline{S_3})
	\\
	(\mathbb{S}', \Sigma') = \mathbf{connect}(\partialo{}{}, E(\overline{S_4}), \partialo{}{}, \overline{S}_2)
	\end{array}
}

\\
\\

\infer[\textsc{$<:$-solve}]
{
	C \cand
	\omega_1 = \mathbb{S}' \cand
	\sigma_1 = \overline{S}' \cand
}
{
	\begin{array}{c}
	C \cand
	\os{1}{1} <: \os{2}{2} \cand
	\omega_1 = \partialo{1}{} \cand
	\sigma_1 = \Sigma_1
	\\
	\begin{array}{cc}
	\omega_2 = \fixedo{2}{} \in C
	&
	\sigma_2 = \overline{S}_2 \in C
	\end{array}
	\\
	(\mathbb{S}', \overline{S}', E) = \mathbf{overlay}(\mathbb{S}_1, \Sigma_1, \mathbb{S}_2, \overline{S}_2)
	\end{array}
}

\\
\\

\infer[\textsc{$\sqcup$-solve}]
{
	C, \,
	\omega_1 = \Omega',
	\sigma_1 = \Sigma'
}
{
	\begin{array}{c}
	C \cand
	\os{1}{1} = \os{2}{2} \sqcup \os{3}{3} \cand
	\omega_1 = \Omega_1 \cand
	\sigma_1 = \Sigma_1
	\\
	\begin{array}{cccc}
	\omega_2 = \fixedo{2} \in C
	&
	\omega_3 = \fixedo{3} \in C
	&
	\sigma_2 = \overline{S}_2 \in C
	&
	\sigma_3 = \overline{S}_3 \in C
	\end{array}
	\\
	(\mathbb{S}_\cup, \overline{S}'_\cup) = \mathbf{union}(\mathbb{S}_2, \overline{S}_2, \mathbb{S}_3, \overline{S}_3)
	\\
	(\Omega', \Sigma') = \mathbf{connect}(\Omega_1, \Sigma_1, \partialo{\cup}{}, \overline{S}_\cup)
	\end{array}	
}

\\
\\

\infer[\textsc{$\veebar$-solve}]
{
	C, \,
	\omega = \Omega, \,
	\sigma_1 = \Sigma
}
{
	\begin{array}{c}
	C \cand
	\os{1}{1} = \os{1}{2} \veebar \os{1}{3} \cand
	\omega_1 = \Omega_1 \cand
	\sigma_1 = \Sigma_1
	\\
	\begin{array}{cc}
	\sigma_2 = \overline{S}_2 \in C
	&
	\sigma_3 = \overline{S}_3 \in C
	\end{array}
	\\
	(\Omega, \Sigma) = \mathbf{connect}(\Omega_1, \Sigma_1, \fixedo{2}{}, \overline{S}_2 \cup \overline{S}_3)
	\end{array}
}


\end{tabular}
\end{center}
\caption{\label{fig:objsolving} Object constraint solving rules}
\end{figure*}


\begin{figure}

\caption{\label{fig:connectdefn} Definition of $\mathbf{connect}$}
\end{figure}

\begin{figure}

\caption{\label{fig:overlaydefn} Definition of $\mathbf{overlay}$}
\end{figure}

\begin{figure}

\caption{\label{fig:overlaydefn} Definition of $\mathbf{union}$}
\end{figure}


\subsection{Implementation}

A Scala implementation of a type checker for TS0 which uses the type inference
technique described can be found at \url{http://github.com/iainmcgin/ts0-lang}.
A topological order is built from the dependency graph between context variables
to efficiently normalise the context constraints. The first order unification 
algorithm presented in \cite{Martelli1982} is used to solve the type variable 
constraints, allowing the effects for the parameters to be extracted from
the context variables.

\section{Conclusion}

TS0 is a small, simple language that has proven useful
for the study of the inference of object protocols, and the theoretical work
done to date holds promise for future expansion and interesting results. 
To our knowledge, this is also the first attempt to study the inference
of generalised typestate in an object oriented context, rather than
more specific inference problems such as session type inference
\cite{Collingbourne2010}. The
constraint generation approach closely aligns with the typing judgements,
which we believe makes the approach intuitive.

\appendix

\section{Soundness}
\label{app:soundness}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%% thm:soundness %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% checked 02/01/2013
%%% depends on: valuectx, upgrade, remap


\begin{thm}[Progress and Preservation]
\label{thm:soundness}
Given a term $t$ such that $\typerule{\Gamma}{t}{T}{\Gamma'}$
with a store $\mu$ such that $\Gamma \vdash \mu$, either $t$ is a value or 
there exists a $t'$ and $\mu'$ such that
$\oprule{t}{\mu}{t'}{\mu'}$, with some $\Gamma''$ such that
$\Gamma'' \vdash \mu'$ and $\typerule{\Gamma''}{t'}{T}{\Gamma'}$.
\end{thm}

\begin{proof}
by induction on the typing derivation of $t$. Assume $t$ is not a value. It has
therefore been typed by one of the following rules:

\begin{itemize}
\item \tlet. It follows that $t = \lett{x}{t_v}{t_b}$, with
$\typerule{\Gamma}{t_v}{T_v}{\Gamma_1}$ and
$\typerule{\Gamma_1, x : T_v}{t_b}{T}{\Gamma', x : T_v'}$ for some
$\Gamma_1$, $T_v$ and $T_v'$.
There are two cases to consider:

  \begin{itemize}
  \item $t_v$ is a value.
  Reduction can occur by \rletv such that 
  $\oprule{\lett{x}{t_v}{t_b}}{\mu}{t_b}{\mu [ x \mapsto t_v ]}$.
  Let $\mu' = \mu [ x \mapsto t_v ]$. Let $\Gamma'' = \Gamma_1, x : T_v$.
  It follows that $\Gamma'' \vdash \mu'$ and by rule \tdrop that
  $\typerule{\Gamma''}{t_b}{T}{\Gamma'}$.

  \item If $t_v$ is not a value, 
  by induction we have that $\oprule{t_v}{\mu}{t_v'}{\mu'}$, with
  some $\Gamma'' \vdash \mu'$ and $\typerule{\Gamma''}{t_v'}{T_v}{\Gamma_1}$.
  This satisfies the requirements of \rlett such that $t$ itself can be reduced:
  $\oprule{\lett{x}{t_v}{t_b}}{\mu}{\lett{x}{t_v'}{t_b}}{\mu'}$.
  Additionally, the conditions of \tlet are satisfied such that
  $\typerule{\Gamma''}{\lett{x}{t_v'}{t_b}}{T}{\Gamma'}$.

  \end{itemize}

\item \tseq. It follows that $t = t_l ; t_r$ with
$\typerule{\Gamma}{t_l}{T_l}{\Gamma_{mid}}$ and
$\typerule{\Gamma_{mid}}{t_r}{T}{\Gamma'}$ for some $\Gamma_{mid}$ and $T_l$.
There are two cases to consider:

  \begin{itemize}
  \item $t_l$ is a value. Reduction can therefore occur by
  \rseqlv such that
  $\oprule{t_l ; t_r}{\mu}{t_r}{\mu}$. 
  Let $\Gamma'' = \Gamma_{mid}$, and $\mu' = \mu$.
  Directly, $\typerule{\Gamma''}{t_r}{T}{\Gamma'}$.
  By \lemref{lem:ctxsubset} it follows that $dom(\Gamma'') \subseteq dom(\Gamma)$,
  and by \lemref{lem:valuectx} it follows that 
  $\forall y \in dom(\Gamma'') . \Gamma(y) <: \Gamma''(y)$.
  Therefore $\Gamma'' \vdash \mu'$.

  \item If $t_l$ is a term, by induction $\oprule{t_l}{\mu}{t_l'}{\mu'}$
  with some $\Gamma'' \vdash \mu'$ and
  $\typerule{\Gamma''}{t_l'}{T_l}{\Gamma_{mid}}$.
  This satisfies the requirements of \rseqlt
  such that $\oprule{t_l ; t_r}{\mu}{t_l' ; t_r}{\mu'}$.
  Additionally, the requirements of \tseq are satisfied such that
  $\typerule{\Gamma''}{t_l'; t_r}{T}{\Gamma'}$.

  \end{itemize}

\item \tfunc. It follows that $t = x ( \overline{x_i} )$ with
$\Gamma = \Gamma_1, \overline{x_i : T_i}$ 
and $\Gamma_1(x) = \funt{U_i}{V_i}{T}$
such that $\forall i . T_i <: U_i$ 
and that $\Gamma' = \Gamma_1, \overline{x_i : T_i'}$
where $T_i' = \remapapp{T_i}{U_i}{V_i}$.

As $\Gamma \vdash \mu$, 
it follows that $\mu(x) = \funv{y_i}{U_i'}{V_i'}{t'}$
where $\typerule{\overline{y_i : U_i'}}{t'}{T'}{\overline{y_i : V_i'}}$,
with $\funt{U_i'}{V_i'}{T'} <: \funt{U_i}{V_i}{T}$. 
Therefore by \subfn for each $i$, $U_i <: U_i'$, $V_i' <: V_i$
and $T' <: T$.
Additionally for each $x_i$, $\mu(x_i) = v_i$ such that 
$\typerule{\emptyset}{v_i}{T_i''}{\emptyset}$ 
where $T_i'' <: T_i$.

Let $t_{sub} = \subst{x_i}{y_i}{t'}$.
The term $t$ can be reduced by \rfunc such that
$\oprule{t}{\mu}{t_{sub}}{\mu}$.
By the substitution lemma, 
$\typerule{\overline{x_i : U_i'}}{t_{sub}}{T'}{\overline{x_i : V_i'}}$.
As $U_i <: U_i'$ for each $i$, by repeated application of lemma 
\lemref{lem:upgrade}, it follows that
there exists a $T'' <: T'$ and $V_i'' <: V_i'$ for each $i$
such that 
$\typerule{\overline{x_i : U_i}}{T_{sub}}{T''}{\overline{x_i : V_i''}}$.

Therefore, by given that $T_i <: U_i$ and that $V_i'' <: V_i' <: V_i$
and that $T'' <: T' <: T$ we can apply \tnarrow, \twiden and \tsub
such that $\typerule{\overline{x_i : T_i}}{t_{sub}}{T}{\overline{x_i : V_i}}$.

Let $\mu' = \mu$. Let $\Gamma'' = \Gamma$. It follows that 
$\Gamma'' \vdash \mu'$. By applying the weakening lemma, we can type 
$t_{sub}$ such that $\typerule{\Gamma''}{t_{sub}}{T}{\Gamma'}$.

\item \tmethc. It follows that $t = x.m$ with
$\Gamma = \Gamma_1, x : O@\overline{S}$ and
$\Gamma' = \Gamma_1, x : O@\overline{S'}$, where
$m : T \Rightarrow \overline{S'} \in O@\overline{S}$.

As
$\Gamma \vdash \mu$, we must have $\mu(x) = o'@S_c$ with
$\typerule{\emptyset}{o'@S_c}{O'@S_c}{\emptyset}$ such that
$O'@S_c <: O@\overline{S}$. 

We must have that
$o' = [ S_c \{ m = (v,S_n) ; ... \} ... ]$, where $O'@S_n <: O@\overline{S'}$. 
It follows that $\typerule{\emptyset}{v}{T'}{\emptyset}$
for some $T'$ such that $T' <: T$.

Therefore reduction can occur by \rmethc such that
$\oprule{t}{\mu}{v}{\mu [x \mapsto o@S_n]}$.
Let $\mu' = \mu [ x \mapsto o@S']$.

Let $\Gamma'' = \Gamma'$. By the appropriate value typing rule for $v$, 
it follows that $\typerule{\Gamma''}{v}{T'}{\Gamma'}$.
By application of rule \tsub, it follows that
$\typerule{\Gamma''}{v}{T}{\Gamma'}$.
Additionally, it follows that
$\Gamma'' \vdash \mu'$, as $O'@S_n <: O@\overline{S'}$.

\item \tif. It follows that $t = \ift{t_c}{t_t}{t_f}$ with
$\typerule{\Gamma}{t_c}{\boolt}{\Gamma_1}$ and
$\typerule{\Gamma_1}{t_t}{T_t}{\Gamma_2}$ and
$\typerule{\Gamma_2}{t_f}{T_f}{\Gamma_3}$ where
$\Gamma' = \Gamma_2 \sqcup \Gamma_3$ and $T = T_t \sqcup T_f$. There are
three possibilities for reduction:

  \begin{itemize}
  \item $t_c = \truev$. By \lemref{lem:valuectx} we have that
  $\forall x \in dom(\Gamma_1) . \Gamma(x) <: \Gamma_1(x)$, and
  by \lemref{lem:ctxsubset} that $dom(\Gamma_1) \subseteq dom(\Gamma)$. 
  Reduction can occur by \riftrue such that
  $\oprule{t}{\mu}{t_t}{\mu}$. By \tsub we have that
  $\typerule{\Gamma_1}{t_t}{T}{\Gamma_2}$ as $T_t <: T$. Additionally, for
  all $x \in \Gamma_2$, $\Gamma_2(x) <: \Gamma'(x)$. Therefore by
  repeatedly applying \twiden for all $x$, we have that
  $\typerule{\Gamma_1}{t_t}{T}{\Gamma'}$.
  Let $\Gamma'' = \Gamma_1$ and $\mu' = \mu$.
  It follows that $\Gamma'' \vdash \mu'$
  and that $\typerule{\Gamma''}{t_t}{T}{\Gamma'}$.

  \item $t_c = \falsev$. By \lemref{lem:valuectx} we have that
  $\forall x \in dom(\Gamma_1) . \Gamma(x) <: \Gamma_1(x)$, and
  by \lemref{lem:ctxsubset} that $dom(\Gamma_1) \subseteq dom(\Gamma)$.
  Reduction can occur by \riffalse such that
  $\oprule{t}{\mu}{t_f}{\mu}$. By \tsub we hhave that
  $\typerule{\Gamma_1}{t_f}{T}{\Gamma_3}$ as $T_f <: T$. Additionally, for
  all $x \in \Gamma_3$, $\Gamma_3(x) <: \Gamma'(x)$. Therefore by
  repeatedly applying \twiden for all $x$, we have that
  $\typerule{\Gamma_1}{t_f}{T}{\Gamma'}$. Let $\Gamma'' = \Gamma_1$
  and $\mu' = \mu$. It follows that $\Gamma'' \vdash \mu'$ and that
  $\typerule{\Gamma''}{t'}{T}{\Gamma'}$.

  \item $t_c$ is not a value. By induction, there exists $t_c'$,
  $\mu'$, $\Gamma''$ such that 
  $\oprule{t_c}{\mu}{t_c'}{\mu'}$ and 
  $\typerule{\Gamma''}{t_c'}{\boolt}{\Gamma_1}$ with $\Gamma'' \vdash \mu'$. 
  Reduction of $t$ can therefore occur by \rifexpr such that
  $\oprule{t}{\mu}{\ift{t_c'}{t_t}{t_f}}{\mu'}$. It follows
  by \tif that $\typerule{\Gamma''}{\ift{t_c'}{t_t}{t_f}}{T}{\Gamma'}$.
  \end{itemize}

\item \tdrop. It follows that there exists a $\Gamma'''$ such that
$\typerule{\Gamma}{t}{T}{\Gamma', \Gamma'''}$. By induction, there exists
a $t'$, $\Gamma''$ and $\mu'$ such that
$\oprule{t}{\mu}{t'}{\mu'}$ with
$\typerule{\Gamma''}{t'}{T}{\Gamma', \Gamma'''}$ where $\Gamma'' \vdash \mu'$.
By application of \tdrop for each $x \in dom(\Gamma''')$, it follows that
$\typerule{\Gamma''}{t'}{T}{\Gamma'}$.

\item \tsub. It follows that there exists a $T' <: T$ such that
$\typerule{\Gamma}{t}{T'}{\Gamma'}$. By induction, there exists a $t'$,
$\Gamma''$ and $\mu'$ such that 
$\oprule{t}{\mu}{t'}{\mu'}$ with
$\typerule{\Gamma''}{t'}{T'}{\Gamma'}$ where
$\Gamma'' \vdash \mu'$. By application of \tsub, it follows that
$\typerule{\Gamma''}{t'}{T}{\Gamma'}$.

\item \twiden. It follows that $\Gamma' = \Gamma_1, x : U$ and that there
exists a $T <: U$ such that $\typerule{\Gamma}{t}{T}{\Gamma_1, x : T}$.
By induction, there exists a $t'$, $\Gamma''$ and $\mu'$ such that
$\oprule{t}{\mu}{t'}{\mu'}$ with $\typerule{\Gamma''}{t'}{T}{\Gamma_1, x : T}$
where $\Gamma'' \vdash \mu'$. By application of \twiden, it follows that
$\typerule{\Gamma''}{t'}{T}{\Gamma'}$.

\item \tnarrow. It follows that $\Gamma = \Gamma_1, x : T$ and that there
exists a $U$ such that $T <: U$ and that $\typerule{\Gamma_1, x : U}{t}{T}{\Gamma'}$.
By induction, there exists a $t'$, $\Gamma''$ and $\mu'$ such that
$\oprule{t}{\mu}{t'}{\mu'}$ with $\typerule{\Gamma''}{t'}{T}{\Gamma'}$ where
$\Gamma'' \vdash \mu'$.

\end{itemize}
\end{proof}

\subsection{Supporting lemmas}
\label{app:proofs}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%% lem:ctxsubset %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% last revised and checked: 2012/12/13

\begin{lem}
\label{lem:ctxsubset}
Given an arbitrary term $t$, it follows that for any judgement
$\typerule{\Gamma}{t}{T}{\Gamma'}$ that $dom(\Gamma') \subseteq dom(\Gamma)$.
\end{lem}
\begin{proof}
by induction on the typing derivation of $t$.

\begin{itemize}
\item $t$ is typed by one of \tunit, \ttrue, \tfalse,
\tobj or \tfundef. It follows that $\Gamma = \Gamma'$. Trivially,
$dom(\Gamma') \subseteq dom(\Gamma)$.

\item $t$ is typed by \tlet. Therefore $t = \lett{x}{t_v}{t_b}$
such that $\typerule{\Gamma}{t_v}{T_v}{\Gamma''}$ and
$\typerule{\Gamma'', x : T_v}{t_b}{T}{\Gamma''', x : T_v'}$
with $\Gamma' = \Gamma'''$.
By induction, $dom(\Gamma'') \subseteq dom(\Gamma)$ and $dom(\Gamma''') \subseteq dom(\Gamma'')$.
Therefore, $dom(\Gamma') \subseteq dom(\Gamma)$.

\item $t$ is typed by \tseq. Therefore $t = t_a ; t_b$ such that
$\typerule{\Gamma}{t_a}{T_a}{\Gamma''}$ and
$\typerule{\Gamma''}{t_b}{T}{\Gamma'}$. By induction,
$dom(\Gamma'') \subseteq dom(\Gamma)$ and $dom(\Gamma') \subseteq dom(\Gamma'')$. Therefore
$dom(\Gamma') \subseteq dom(\Gamma)$.

\item $t$ is typed by \tfunc. It follows that $dom(\Gamma') = dom(\Gamma)$,
therefore $dom(\Gamma') \subseteq dom(\Gamma)$

\item $t$ is typed by \tmethc. It follows that $dom(\Gamma') = dom(\Gamma)$,
therefore $dom(\Gamma') \subseteq dom(\Gamma)$.

\item $t$ is typed by \tif. If follows that $t = \ift{t_c}{t_t}{t_f}$
with $\typerule{\Gamma}{t_c}{\boolt}{\Gamma_c}$
and $\typerule{\Gamma_c}{t_t}{T_t}{\Gamma_t}$
and $\typerule{\Gamma_c}{t_f}{T_f}{\Gamma_f}$ such that
$\Gamma' = \Gamma_t \sqcup \Gamma_f$.

By induction, $dom(\Gamma_c) \subseteq dom(\Gamma)$ and
$dom(\Gamma_t) \subseteq dom(\Gamma_c)$ and
$dom(\Gamma_f) \subseteq dom(\Gamma_c)$. $\Gamma' = \Gamma_t \sqcup \Gamma_f$
is only defined where $dom(\Gamma_t) = dom(\Gamma_f)$ therefore
$dom(\Gamma') = dom(\Gamma_t)$. It follows that
$dom(\Gamma') \subseteq dom(\Gamma)$.

\item $t$ is typed by \tdrop. Directly, $dom(\Gamma') \subseteq dom(\Gamma)$.

\item $t$ is typed by \tsub, \twiden or \tnarrow. In each case
$dom(\Gamma') = dom(\Gamma)$. Trivially, $dom(\Gamma') \subseteq dom(\Gamma)$.

\end{itemize}
\end{proof}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%% lem:unused %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lem}
\label{lem:unused}
Given an arbitrary term $t$ such that 
$\typerule{\Gamma, x : T}{t}{T}{\Gamma', x : V}$ where $x$ is unused in
$t$, $T <: V$.
\end{lem}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%% lem:valuectx %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% last revised and checked: 2012/12/13

\begin{lem}
\label{lem:valuectx}
Given an arbitrary value $v$, it follows that for any judgement
$\typerule{\Gamma}{v}{T}{\Gamma'}$ that 
$\forall x \in \Gamma' . \Gamma(x) <: \Gamma'(x)$.
\end{lem}
\begin{proof}
by induction on the typing derivation of $v$.

\begin{itemize}
\item $v$ is typed by one of \tunit, \ttrue, \tfalse,
\tobj or \tfundef. It follows that $\Gamma' = \Gamma$. Trivially,
$\forall x \in \Gamma' . \Gamma(x) <: \Gamma'(x)$.

\item $v$ is typed by \tdrop. It follows that $\typerule{\Gamma}{v}{T}{\Gamma''}$
where $\Gamma'' = \Gamma', \Gamma'''$. By induction,
$\forall x \in \Gamma'' . \Gamma(x) <: \Gamma''(x)$.
By definition, $\forall x \in \Gamma' . \Gamma'(x) = \Gamma''(x)$.
Therefore, $\forall x \in \Gamma' . \Gamma(x) <: \Gamma'(x)$.

\item $v$ is typed by \tsub. It follows that $\Gamma = \Gamma'$. Trivially,
$\forall x \in \Gamma' . \Gamma(x) <: \Gamma'(x)$.

\item $v$ is typed by \twiden. It follows that $\typerule{\Gamma}{v}{T}{\Gamma'''}$
where $\Gamma''' = \Gamma'', x : T$ and $\Gamma' = \Gamma'', x : U$ with
$T <: U$. By induction, $\forall x \in \Gamma''' . \Gamma(x) <: \Gamma'''(x)$.
By definition, $\forall x \in \Gamma' . \Gamma'''(x) <: \Gamma'(x)$. Transitively,
$\forall x \in \Gamma' . \Gamma(x) <: \Gamma'(x)$.

\item $v$ is typed by \tnarrow. It follows that $\typerule{\Gamma''}{v}{T}{\Gamma'}$,
where $\Gamma'' = \Gamma''', x : U$ and $\Gamma = \Gamma''', x : T$ where
$T <: U$. By induction, $\forall x \in \Gamma' . \Gamma''(x) <: \Gamma'(x)$.
By definition, $\forall x \in \Gamma . \Gamma(x) <: \Gamma''(x)$ and
$dom(\Gamma'') = dom(\Gamma)$. Therefore
$\forall x \in \Gamma . \Gamma(x) <: \Gamma'(x)$.

\end{itemize}
\end{proof}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%% lem:ssetinc  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% last revised and checked: 2012/12/13

\begin{lem}
\label{lem:ssetinc}
Given an object protocol $O = \left\{ \overline{ S_i \{ ... \} } \right\}$ and two state sets 
$\overline{S} \subseteq \overline{S'} \subseteq \overline{S_i}$, it follows
that $O@\overline{S} <: O@\overline{S'}$.
\end{lem}
\begin{proof}
From the definition of state sets, we have that 
$O@\overline{S} = \bigsqcup_{S \in \overline{S}}{O@S}$ and that
$O@\overline{S'} = \bigsqcup_{S \in \overline{S'}}{O@S}$.
As $\overline{S} \subseteq \overline{S'}$ there exists an
$\overline{S''}$ such that $\overline{S'} = \overline{S} \cup \overline{S''}$
where $\overline{S} \cap \overline{S''} = \emptyset$. Therefore
$O@\overline{S'} = \left(\bigsqcup_{S \in \overline{S}}{O@S}\right) \sqcup \left(\bigsqcup_{S' \in \overline{S'} - \overline{S}}{O@S'}\right)$.

As $A <: A \sqcup B$ for all $A$ and $B$ where $A \sqcup B$ is defined, 
it follows that $O@\overline{S} <: O@\overline{S'}$.
\end{proof}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%% lem:remap %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% last revised and checked: 2012/12/13

\begin{lem}
\label{lem:remap}
Given types $T$, $U$, and $V$, such that
$\remapapp{T}{U}{V}$ is defined, it follows that $\remapapp{T}{U}{V} <: V$.
\end{lem}
\begin{proof}
By case analysis of V.

\begin{itemize}
\item $V = \unitt$ or $V = \boolt$. By either rule \remapunit or \remapbool
it must be the case that $U = V$. It must also be the case that
$T = U$, as $\unitt$ and $\boolt$ do not have any subtypes other than
themselves. Therefore $V = \remapapp{T}{U}{V} <: V$ by \subrefl.

\item $V = \funv{V_i}{V_i'}{V'}$. By \remapfunc, 
$T <: U$, $U = V$ and $T = \remapapp{T}{U}{V}$. Therefore, $T <: V$.

\item $V = \ot{O_1}{S_3}$. By
\remapobj, $T = \ot{O_2}{S_2}$ and $U = \ot{O_1}{S_1}$
where $T <: U$. It follows that $\ot{O_1}{S_4} = \remapapp{T}{U}{V}$
where 
$\overline{S_4} = \bigcup \{ \overline{S} \mid (\ot{O_2}{S_2}, \ot{O_1}{S_1}) \lesssim (\ot{O_2}{S}, \ot{O_1}{S_3}) \}$. By definition, $\ot{O_1}{S_4} <: \ot{O_2}{S_3}$.

\end{itemize}
\end{proof}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%% lem:remapcv %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lem}[Remap is covariant]
\label{lem:remapcv}
Given types $T, T', U$ and $V$ such that $T <: T'$ and
$\remapapp{T}{U}{V}$ is defined,
$\remapapp{T}{U}{V} <: \remapapp{T'}{U}{V}$.
\end{lem}
\begin{proof}
by case analysis of type $U$.

\begin{itemize}
\item $U = \boolt$ or $\unitt$. By \remapunit or \remapbool, it follows
that $T = \remapapp{T}{U}{V}$. 
As $\boolt$ and $\unitt$ have no subtypes other than
themselves, it follows that $T' = T$. Trivially,
$\remapapp{T'}{U}{V} = \remapapp{T}{U}{V}$.

\item $U = \funt{U_i}{U_i'}{U'}$. By \remapfunc it follows that
$\remapapp{T'}{U}{V} = T' <: T = \remapapp{T}{U}{V}$.

\item $U = \ot{O_2}{S_2}$, with $T = \ot{O_1}{S_1}$ and $V = \ot{O_2}{S_4}$
and $\ot{O_1}{S_3} = \remapapp{T}{U}{V}$. Let $T' = \ot{O_3}{S_5}$,
and $\ot{O_3}{S_6} = \remapapp{T'}{U}{V}$. By definition,
$\overline{S_3} = \bigcup \{ \overline{S} \mid (\ot{O_1}{S_1}, \ot{O_2}{S_2}) \lesssim (\ot{O_1}{S}, \ot{O_2}{S_4}) \}$, and
$\overline{S_6} = \bigcup \{ \overline{S'} \mid (\ot{O_3}{S_5}, \ot{O_2}{S_2}) \lesssim (\ot{O_3}{S}, \ot{O_2}{S_4}) \}$.
In both cases, each $\overline{S}$ and $\overline{S'}$ extracted from
the path relation must be such that 
$(\ot{O_3}{S_5}, \ot{O_1}{S_1}) \lesssim (\ot{O_3}{S'}, \ot{O_1}{S})$.
Therefore, $\ot{O_3}{S_6} <: \ot{O_1}{S_3}$.

\end{itemize}
\end{proof}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%% lem:remap_in_contra %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{lem}
\label{lem:remap_in_contra}
Given types $T, U, U'$ and $V$ such that $U' <: U$ and that
both $\remapapp{T}{U'}{V}$ and $\remapapp{T}{U}{V}$ are defined,
$\remapapp{T}{U}{V} <: \remapapp{T}{U'}{V}$.
\end{lem}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%% lem:remap_out_cv %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lem}
\label{lem:remap_out_cv}
Given types $T, U, V$ and $V'$ such that $V' <: V$ and that
both $\remapapp{T}{U}{V}$ and $\remapapp{T}{U}{V'}$ are defined,
$\remapapp{T}{U}{V'} <: \remapapp{T}{U}{V}$.
\end{lem}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%% lem:lesssim_same %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lem}
\label{lem:lesssim_same}
Let $\overline{S'}$ and $\overline{S''}$ be state sets such that
$(\ot{O}{S}, \ot{O}{S}) \lesssim (\ot{O}{S'}, \ot{O}{S''})$. It follows
that $\overline{S'} = \overline{S''}$.
\end{lem}

\begin{proof}
TODO (coinductive?)
\end{proof}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%% lem:remapsame %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lem}
\label{lem:remapsame}
Given a type $T$, $T = \remapapp{T}{T}{T}$.
\end{lem}

\begin{proof}
by case analysis of the type $T$.

\begin{itemize}
\item $T = \unitt$ or $T = \boolt$. 
Directly by rule \remapunit or \remapbool, $T = \remapapp{T}{T}{T}$

\item $T = \funt{T_i}{T_i'}{T'}$. Directly by rule
\remapfunc, $T = \remapapp{T}{T}{T}$.

\item $T = \ot{O}{S_1}$. Let $\ot{O}{S_2} = \remapapp{T}{T}{T}$. By definition,
$\overline{S_2} = \bigcup \{ \overline{S} \mid (\ot{O}{S_1}, \ot{O_1}{S_1}) \lesssim (\ot{O_1}{S}, \ot{O_1}{S_1}) \}$. By \lemref{lem:lesssim_same}, it follows that
$\overline{S} = \overline{S_1}$ for all $\overline{S}$. Therefore,
$\overline{S_2} = \overline{S_1}$.
\end{itemize}
\end{proof}


\begin{lem}
\label{lem:remapeff}
Given types $T$, $U$ and $V$ such that $U <: V$.
It follows that $U <: \remapapp{U}{V}{V}$.
\end{lem}
\begin{proof}
By case analysis of the type $V$.

\begin{itemize}
\item $V = \unitt$ or $V = \boolt$. By rule \remapunit or \remapbool,
$\remapapp{U}{V}{V} = U$. By \subrefl $U <: U$.

\item $V = \funt{T_i}{T_i'}{T_r}$. By rule \remapfunc
$\remapapp{U}{V}{V} = U$. By \subrefl $U <: U$.

\item $V = \ot{O_2}{S_2}$, with $U = \ot{O_1}{S_1}$.
By rule \remapobj, $\remapapp{\ot{O_1}{S_1}}{\ot{O_2}{S_2}}{\ot{O_2}{S_2}} = \ot{O_1}{S_3}$ where
$\overline{S_3} = \bigcup \{ \overline{S} \mid (\ot{O_1}{S_1}, \ot{O_2}{S_2}) \lesssim (\ot{O_1}{S}, \ot{O_2}{S_2}) \}$.
By rule $\lesssim$\textsc{-refl},
$(\ot{O_1}{S_1}, \ot{O_2}{S_2}) \lesssim (\ot{O_1}{S_1}, \ot{O_2}{S_2})$,
therefore $\overline{S_1} \subseteq \overline{S_3}$. It follows that
$\ot{O_1}{S_1} <: \ot{O_1}{S_3}$ by \lemref{lem:ssetinc}.

\end{itemize}
\end{proof}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%% lem:upgrade %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Revised and checked 2012/12/13
%%% DEPENDS ON: unused, weakening, remap

\begin{lem}
\label{lem:upgrade}
If a term $t$ can be typed such that 
$\typerule{\Gamma, x : T}{t}{U}{\Gamma', x : V}$, and if
$T' <: T$, then there exists a $V' <: V$
and $U' <: U$
such that $\typerule{\Gamma, x : T'}{t}{U'}{\Gamma', x : V'}$.
\end{lem}
\begin{proof}
by induction on the typing derivation of $t$.
The term $t$ is of one of the following forms:

\begin{itemize}
\item $t$ is typed by one of \tunit, \ttrue, \tfalse, \tobj or \tfundef.
Therefore, $T = V$.
The environment can be arbitrary in these typing rules,
therefore we can type $t$ such that 
$\typerule{\Gamma, x : T'}{t}{U}{\Gamma', x : T'}$.
Let $V' = T'$, and $U' = U$.

\item $t$ is typed by \tlet. Therefore $t = \lett{y}{t'}{t''}$ and
$x \neq y$ (as variables cannot be rebound), with
$\typerule{\Gamma, x : T}{t'}{Y}{\Gamma_1, x : T_2}$ and
$\typerule{\Gamma_1, x : T_2, y : Y}{t''}{U}{\Gamma', x : V, y : Y_2}$
for some $\Gamma_1, T_2, Y$ and $Y_2$.

By induction, it follows that there exists a $T_3 <: T_2$ 
and $Y_3 <: Y$
such that
$\typerule{\Gamma, x : T'}{t'}{Y_3}{\Gamma_1, x : T_3}$.

By induction, it follows that there exists a type $T_4 <: V$
and $U_2 <: U$
such that
$\typerule{\Gamma_1, x : T_3, y : Y}{t''}{U_2}{\Gamma', x : T_4, y : Y_2}$.
By a second application of the induction hypothesis, it follows that there
exists a $Y_4 <: Y_2$
and $U_3 <: U_2$ such that
$\typerule{\Gamma_1, x : T_3, y : Y_2}{t''}{U_3}{\Gamma', x : T_4, y : Y_4}$.

Let $V' = T_4$. Let $U' = U_3$. By rule \tlet
$\typerule{\Gamma, x : T'}{t}{U'}{\Gamma', x : V'}$.


\item $t$ is typed by \tfunc. Therefore $t = y ( \overline{z_i} )$.
There are three cases to consider:

\begin{itemize}
	\item $x \neq y$ and $x \notin \overline{z_i}$, meaning that
	$x$ is unused in this function call. By \lemref{lem:unused}
	it follows that $T <: V$, and that
	$\typerule{\Gamma}{t}{U}{\Gamma'}$.
	By \lemref{lem:weakening},
	$\typerule{\Gamma, x : T'}{t}{U}{\Gamma', x : T'}$.
	Let $V' = T'$ and $U' = U$.
	Therefore
	$\typerule{\Gamma, x : T'}{t}{U'}{\Gamma', x : V'}$
	with $V' <: V$ (transitively) and $U' <: U$ (reflexively).

	\item $x = y$.
	Therefore $T = \funt{T_i}{T_i'}{U}$, with
	$\Gamma(z_i) = T_i$ and $\Gamma'(z_i) = T_i'$ for each $i$.
	Additionally, $T = V$ by \tfunc.

	$T'$ must therefore be of form $\funt{W_i}{W_i'}{W}$ where
	$T_i <: W_i$ and $W_i' <: T_i'$ and $W <: U$
	by \subfn. Let $V' = T'$. Let $U' = W$.
	Let $\Gamma''$ be a context such that

		\begin{itemize}
		\item $dom(\Gamma'') = dom(\Gamma')$
		\item $\Gamma''(z_i) = \remapapp{\Gamma(z_i)}{W_i}{W_i'}$ for each $z_i$.
		\item $\forall a \notin \overline{z_i} . \Gamma''(a) = \Gamma'(a)$
		\end{itemize}

	It follows by rule \tfunc that $\typerule{\Gamma, x : T'}{t}{U'}{\Gamma'', x : T'}$.
	By \lemref{lem:remap}, $\Gamma''(z_i) <: W_i' <: \Gamma'(z_i)$ for each
	$z_i$. Therefore by repeated application of \twiden for each $z_i$,
	$\typerule{\Gamma, x : T'}{t}{U'}{\Gamma', x : V'}$,
	with $U' <: U$ and $V <: V$.

	%%% V' = remap(T', T >> V)
	\item $x \in \overline{z_i}$. 
	By \tfunc it follows that $\Gamma(y) = \funt{U_i}{V_i}{U}$
	and that $T = U_i$ and $V = V_i$ for some $i$.
	Let $V' = \remapapp{T'}{T}{V}$ and $U' = U$. It follows that
	$\typerule{\Gamma, x : T'}{t}{U}{\Gamma, x : V'}$,
	with $U' <: U$ and
	$V' <: V'$ by \lemref{lem:remap}.
\end{itemize}

%%% V' = T' or is a subtype of remap(T', T >> V)
\item $t$ is typed by \tmethc. Therefore $t = y.m$.
There are two cases to consider:

\begin{itemize}
	\item $x = y$. It follows that $T = \ot{O_1}{S_1}$, and that
	$V = \ot{O_1}{S_3}$, with $m : U \Rightarrow \overline{S_3} \in \ot{O_1}{S_1}$.
	It must therefore be the case that $T' = \ot{O_2}{S_2}$ where
	$\ot{O_2}{S_2} <: \ot{O_1}{S_1}$. Therefore,
	$m : U' \Rightarrow \overline{S_4} \in \ot{O_2}{S_2}$ with
	$U' <: U$. Let $V' = \ot{O_2}{S_4}$. By the definition of object subtyping,
	$V' <: V$.
	By rule \tmethc, $\typerule{\Gamma, x : T'}{t}{U'}{\Gamma', x : V'}$.

	\item $x \neq y$, meaning that $x$ is unused by this method call.
	By \lemref{lem:unused} $T <: V$. By \tmethc it follows that
	$\typerule{\Gamma}{t}{U}{\Gamma'}$.

	By \lemref{lem:weakening},
	$\typerule{\Gamma, x : T'}{t}{U}{\Gamma', x : T'}$.
	Let $V' = T'$ and $U' = U$. Reflexively, $V' <: V$ and $U' <: U$.

\end{itemize}

\item $t$ is typed by \tlet. It follows that $t = t_a ; t_b$ and 
that there exists
$\Gamma'', T_{mid}$ and $T_a$ 
such that $\typerule{\Gamma, x : T}{t_a}{T_a}{\Gamma'', x : T_{mid}}$
and that $\typerule{\Gamma'', x : T_x}{t_b}{U}{\Gamma', x : V}$.

By induction, it follows that there exists $T_{mid}' <: T_{mid}$
and $T_a' <: T_a$
such that $\typerule{\Gamma, x : T'}{t_a}{T_a'}{\Gamma'', x : T_{mid}'}$.

By induction, it follows that 
there exists $V' <: V$ 
and $U' <: U$
such that
$\typerule{\Gamma'', x : T_{mid}'}{t_b}{U'}{\Gamma'', x : V'}$.

By rule \tlet it follows that
$\typerule{\Gamma, x : T'}{t}{U'}{\Gamma'', x : V'}$.

\item $t$ is typed by \tif. It follows that $t = \ift{t_c}{t_t}{t_f}$ 
such that:

\begin{itemize}
\item $\typerule{\Gamma, x : T}{t_c}{\boolt}{\Gamma_1, x : V_c}$
\item $\typerule{\Gamma_1, x : V_c}{t_t}{U_t}{\Gamma_2, x : V_t}$
\item $\typerule{\Gamma_1, x : V_c}{t_f}{U_f}{\Gamma_3, x : V_f}$
\end{itemize}

Additionally, $\Gamma' = \Gamma_2 \sqcup \Gamma_3$, 
$U = U_t \sqcup U_f$ and
$V = V_t \sqcup V_f$.

By induction, there exists a $V_c' <: V_c$
and $U_c <: \boolt$
such that $\typerule{\Gamma, x : T'}{t_c}{U_c}{\Gamma_1, x : V_c'}$.
Trivially, $U_c = \boolt$.

By induction there exists a 
$V_t' <: V_t$ and $U_t' <: U_t$ such that
$\typerule{\Gamma_1, x : V_c'}{t_t}{U_t'}{\Gamma_2, x : V_t'}$.

By induction there exists a 
$V_f' <: V_f$ and $U_f' <: U_f$
such that $\typerule{\Gamma_1, x : V_c'}{t_f}{U_f'}{\Gamma_3, x : V_f'}$.

Let $V' = V_t' \sqcup V_f'$, and $U' = U_t' \sqcup U_f'$.
By the definition of type join, $V' <: V$ and $U' <: U$.
By rule \tif it follows that
$\typerule{\Gamma, x : T'}{t}{U'}{\Gamma', x : V'}$.

\item $t$ is typed by \tdrop. It follows that
$\typerule{\Gamma, x : T}{t}{U}{\Gamma''', x : V}$ where
$\Gamma''' = \Gamma', \Gamma''$ for some $\Gamma''$. By induction,
there exists a $V' <: V$ and $U' <: U$ such that
$\typerule{\Gamma, x : T'}{t}{U'}{\Gamma''', x : V'}$. By
rule \tdrop, it follows that
$\typerule{\Gamma, x : T'}{t}{U'}{\Gamma', x : V'}$.

\item $t$ is typed by \tsub. It follows that
$\typerule{\Gamma, x : T}{t}{W}{\Gamma', x : V}$ for some $W <: U$.
By induction, there exists a $V' <: V$ and $U' <: W$
such that
$\typerule{\Gamma, x : T'}{t}{U'}{\Gamma', x : V'}$. Transitively,
$U' <: U$.

\item $t$ is typed by \twiden. There are two possibilities:

	\begin{itemize}
	\item $x$ is the subject of widening in the output context.
	Therefore $\typerule{\Gamma, x : T}{t}{U}{\Gamma', x : W}$ where $W <: V$.
	By induction, there exists a $W' <: W$ and $U' <: U$
	$\typerule{\Gamma, x : T'}{t}{U'}{\Gamma', x : W'}$. Let $V' = W'$.

	\item $x$ is not the subject of widening. Therefore
	$\typerule{\Gamma, x : T}{t}{U}{\Gamma'', x : V}$ such that
	$\Gamma'' = \Gamma''', y : Y'$ and $\Gamma' = \Gamma''', y : Y$
	where $Y' <: Y$.

	By induction, there exists a $V' <: V$ and
	$U' <: U$ such that
	$\typerule{\Gamma, x : T'}{t}{U'}{\Gamma'', x : V'}$.

	By application of \twiden on $y$, it follows that
	$\typerule{\Gamma}{t}{U'}{\Gamma', x : V'}$.

	\end{itemize}

\item $t$ is typed by \tnarrow. There are two possibilities:

	\begin{itemize}

	\item $x$ is the subject of narrowing in the input context.
	Therefore $\typerule{\Gamma, x : W}{t}{U}{\Gamma', x : V}$ where $T <: W$.
	Transitively, $T' <: W$.
	By induction, there exists a 
	$V' <: V$ and $U' <: U$
	such that $\typerule{\Gamma, x : T'}{t}{U'}{\Gamma', x : V'}$.

	\item $x$ is not the subject of narrowing in the input context.
	Therefore $\typerule{\Gamma'', x : T}{t}{U}{\Gamma', x : V}$ where
	$\Gamma'' = \Gamma''', y : Y$ and $\Gamma = \Gamma''', y : Y'$ where
	$Y' <: Y$.

	By induction, there exists a $V' <: V$ and $U' <: U$
	such that $\typerule{\Gamma'', x : T'}{t}{U}{\Gamma', x : V'}$.
	By application of \tnarrow to $y$, 
	$\typerule{\Gamma, x : T'}{t}{U}{\Gamma', x : V'}$.

	\end{itemize}

\end{proof}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%% lem:weakening %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% Last revised and checked: 2012/12/13

\begin{lem}[Weakening]
\label{lem:weakening}
If $\typerule{\Gamma}{t}{T}{\Gamma'}$,
then for all $\Gamma''$ such that $dom(\Gamma) \cap dom(\Gamma'') = \emptyset$,
$t$ can also be typed such that
$\typerule{\Gamma, \Gamma''}{t}{T}{\Gamma', \Gamma''}$.
\end{lem}
\begin{proof}
by induction on the typing derivation of $t$.

\begin{itemize}
\item $t$ is typed by one of \tunit, \ttrue, \tfalse, \tobj or \tfundef.
It follows that $\Gamma = \Gamma'$ and the term can be typed with any
context $\Gamma'''$ such that $\typerule{\Gamma'''}{t}{T}{\Gamma'''}$
using the same rule. 
Therefore, $\typerule{\Gamma, \Gamma''}{t}{T}{\Gamma', \Gamma''}$.

\item $t$ is typed by \tlet. It follows that $t = \lett{x}{t'}{t''}$ and
there exists $\Gamma_1, \Gamma_2, T', T''$ such that
$\typerule{\Gamma}{t'}{T'}{\Gamma_1}$ and
$\typerule{\Gamma_1, x : T'}{t''}{T}{\Gamma', x : T''}$,
with $dom(\Gamma') = dom(\Gamma)$.

By induction, $t'$ can be typed such
that $\typerule{\Gamma,\Gamma''}{t'}{T'}{\Gamma_1,\Gamma''}$,
and $t''$ can be typed such that
$\typerule{\Gamma_1, \Gamma'', x : T'}{t''}{T}{\Gamma', \Gamma'', x : T''}$.
We can assume by Barendregt's convention that $x$ can be made distinct from
any variable names in $\Gamma''$ by relabeling $x$.
Therefore by rule \tlet
$\typerule{\Gamma, \Gamma''}{t}{T}{\Gamma', \Gamma''}$.

\item $t$ is typed by \tfunc. It follows that
there exists a $\Gamma_1, \overline{T_i}, \overline{U_i}, \overline{V_i}, \overline{T_i'}$ 
such that 
$\Gamma = \Gamma_1, x : (\overline{U_i \gg V_i}) \rightarrow T, \overline{x_i : T_i}$
and that
$\Gamma' = \Gamma_1, x : (\overline{U_i \gg V_i}) \rightarrow T, \overline{x_i : T_i'}$.
As $\Gamma_1$ can be arbitrary in the rule \tfunc, it follows that we
can extend the input and output contexts such that
$\typerule{\Gamma, \Gamma''}{t}{T}{\Gamma', \Gamma''}$.

\item $t$ is typed by \tmethc. It follows that there exists
a $\Gamma_1$ such that $\Gamma = \Gamma_1, x : O@\overline{S}$ and that 
$\Gamma' = \Gamma_1, x : O@\overline{S'}$.
As $\Gamma_1$ can be arbitrary in rule \tmethc, it follows that we can
extend the input and out contexts such that
$\typerule{\Gamma, \Gamma''}{x.m}{T}{\Gamma', \Gamma''}$.

\item $t$ is typed by \tseq. Therefore $t = t' ; t''$ and there exists
$\Gamma_1$ and $T'$ such that $\typerule{\Gamma}{t'}{T'}{\Gamma_1}$
and $\typerule{\Gamma_1}{t''}{T}{\Gamma'}$. By \lemref{lem:ctxsubset}
it follows that $dom(\Gamma') \subseteq dom(\Gamma_1) \subseteq dom(\Gamma)$.

By induction
$\typerule{\Gamma, \Gamma''}{t'}{T'}{\Gamma_1, \Gamma''}$
and 
$\typerule{\Gamma_1, \Gamma''}{t''}{T}{\Gamma', \Gamma''}$,
as $dom(\Gamma_1) \cap dom(\Gamma'') = \emptyset$.

Therefore by \tseq, 
$\typerule{\Gamma, \Gamma''}{t'}{T'}{\Gamma_1, \Gamma''}$.

\item $t$ is typed by \tif. Therefore $t = \ift{t_c}{t_t}{t_f}$. and there
exists $\Gamma_1$, $\Gamma_2$, $\Gamma_3$, $T_t$ and $T_f$ such that:

\begin{itemize}
\item $\typerule{\Gamma}{t_c}{\boolt}{\Gamma_1}$
\item $\typerule{\Gamma_1}{t_t}{T_t}{\Gamma_2}$
\item $\typerule{\Gamma_1}{t_f}{T_f}{\Gamma_3}$
\end{itemize}

Additionally, $\Gamma' = \Gamma_2 \sqcup \Gamma_3$.
Context join is only defined where $dom(\Gamma_2) = dom(\Gamma_3)$,
and by definition $dom(\Gamma') = dom(\Gamma_2)$.

By induction, $\typerule{\Gamma, \Gamma''}{t_c}{\boolt}{\Gamma_1, \Gamma''}$.

By induction, $\typerule{\Gamma_1, \Gamma''}{t_t}{T_t}{\Gamma_2, \Gamma''}$
as by \lemref{lem:ctxsubset} we have that $dom(\Gamma_1) \subseteq dom(\Gamma)$,
therefore $dom(\Gamma_1) \cap dom(\Gamma'') = \emptyset$.

Similarly by induction, 
$\typerule{\Gamma_1, \Gamma''}{t_f}{T_f}{\Gamma_2, \Gamma''}$.

Therefore by \tif, $\typerule{\Gamma, \Gamma''}{t}{T}{\Gamma', \Gamma''}$.

\item $t$ is typed by \tdrop, therefore $\typerule{\Gamma}{t}{T}{\Gamma', \Gamma'''}$
for some $\Gamma'''$. By induction it follows that
$\typerule{\Gamma, \Gamma''}{t}{T}{\Gamma', \Gamma'', \Gamma'''}$.
Therefore by rule \tdrop,
$\typerule{\Gamma, \Gamma''}{t}{T}{\Gamma', \Gamma''}$.

\item $t$ is typed by \tsub. It follows that $\typerule{\Gamma}{t}{T'}{\Gamma'}$
for $T' <: T$. By induction, $\typerule{\Gamma, \Gamma''}{t}{T'}{\Gamma', \Gamma''}$.
Therefore by rule \tsub, $\typerule{\Gamma, \Gamma''}{t}{T}{\Gamma', \Gamma''}$.

\item $t$ is typed by \twiden. It follows that $\typerule{\Gamma}{t}{T}{\Gamma_{out}, x : U'}$
where $\Gamma' = \Gamma_{out}, x : U$ where $U' <: U$. 
By \lemref{lem:ctxsubset} it must be the case that $x \in dom(\Gamma)$, there
$x \notin dom(\Gamma'')$.
By induction,
$\typerule{\Gamma, \Gamma''}{t}{T}{\Gamma_{out}, \Gamma'', x : U'}$.
By \twiden, 
$\typerule{\Gamma, \Gamma''}{t}{T}{\Gamma_{out}, \Gamma'', x : U}$.

\item $t$ is typed by \tnarrow. It follows that
$\typerule{\Gamma_{in}, x : U}{t}{T}{\Gamma'}$
where $\Gamma = \Gamma_{in}, x : U'$ where $U' <: U$.
By induction,
$\typerule{\Gamma_{in}, \Gamma'', x : U'}{t}{T}{\Gamma', \Gamma''}$.
By rule \tnarrow,
$\typerule{\Gamma, \Gamma''}{t}{T}{\Gamma', \Gamma''}$.
\end{itemize}
\end{proof}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%% lem:subst %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lem}[Substitution]
\label{lem:subst}
If $\typerule{\Gamma}{t}{T}{\Gamma'}$, then
$\typerule
{\subst{x_i}{y_i}{\Gamma}}
{\subst{x_i}{y_i}{t}}
{T}
{\subst{x_i}{y_i}{\Gamma'}}$
where each $x_i$ and $y_i$ is distinct, and $\overline{x_i} \cap \overline{y_i} = \emptyset$.
\end{lem}
\begin{proof}
by induction on the structure of $t$.

If $t$ is some value $v$, then $\Gamma = \Gamma'$, therefore
$\subst{x_i}{y_i}{\Gamma} = \subst{x_i}{y_i}{\Gamma'}$
and substitution has no effect on the value, which has no specific requirements
of either $\Gamma$ or $\Gamma'$ other than that they are equal.
Therefore, $\typerule{\subst{x_i}{y_i}{\Gamma}}{\subst{x_i}{y_i}{v}}{T}{\subst{x_i}{y_i}{\Gamma'}}$.

If $t$ is a term, then it is of one of the following forms:

\begin{itemize}
\item $t = \lett{x}{t''}{t'}$. 
Substitution is defined on this term such that \\
$\subst{x_i}{y_i}{t} \equiv 
\lett{x}{( \subst{x_i}{y_i}{t''} )}{(\subst{x_j}{y_j}{t'})}$
, where $\overline{y_j} = \overline{y_i} - \{ x \}$.

By rule \tlet, it follows
that there exists $T', T'', \Gamma_1$ such that
$\typerule{\Gamma}{t''}{T''}{\Gamma_1}$ and that
$\typerule{\Gamma_1, x : T''}{t''}{T}{\Gamma', x : T'}$.
Additionally, $x \notin dom(\Gamma)$.

By induction, $t''$ can be substituted such that 
$\typerule
{\subst{x_i}{y_i}{\Gamma}}
{\subst{x_i}{y_i}{t''}}
{\subst{x_i}{y_i}{\Gamma_1}}
$.
Additionally, $t'$ can be substituted such that
$(\subst{x_j}{y_j}{\Gamma_1}) , x : T'' \triangleright \subst{x_j}{y_j}{t''} \triangleleft \{ (\overline{x_j / y_j} \} \Gamma') , x : T'$ as it is guaranteed that $x \notin \overline{y_j}$.
As $dom(\Gamma') = dom(\Gamma)$, and that $x \notin dom(\Gamma)$, it follows that $\subst{x_i}{y_i}{\Gamma_1} = (\subst{x_j}{y_j}{\Gamma_1})$ and
that $\overline{x_i / y_i} \} \Gamma' = \overline{x_j / y_j} \} \Gamma'$.

Therefore, the requirements of \tlet are satisfied such that
$\typerule{\subst{x_i}{y_i}{\Gamma}}{\subst{x_i}{y_i}{t}}{T}{\subst{x_i}{y_i}{\Gamma'}}$.

\item $t = t_l ; t_r$.
Substitution is defined on this term such that
$\{ \overline{x_i / y_i} \} ( t_l ; t_r ) \equiv \subst{x_i}{y_i}{t_l} ; \subst{x_i}{y_i}{t_r}$.

By rule \tseq, there exists $\Gamma'', T'$ such that
$\typerule{\Gamma}{t_l}{T'}{\Gamma''}$ and
$\typerule{\Gamma''}{t_r}{T}{\Gamma'}$. By induction,
$\typerule{\subst{x_i}{y_i}{\Gamma}}{\subst{x_i}{y_i}{t_l}}{T'}{\subst{x_i}{y_i}{\Gamma''}}$ and
$\typerule{\subst{x_i}{y_i}{\Gamma''}}{\subst{x_i}{y_i}{t_r}}{T}{\subst{x_i}{y_i}{\Gamma'}}$.
Therefore, $t$ can by typed \tseq after the substitution.

\item $t = x_0 ( \overline{x_k} )$.
Substition is defined on this term such that
$\subst{x_i}{y_i}{x_0} ( \overline{x_k} ) \equiv y_0 ( \overline{y_k} )$
where for each $x \in \{ x_0, \overline{x_k} \}$,
$x = y_j \implies y = x_j$, otherwise $y$ is the original value.

For each substitution that occurs in the term, the variable must exist in
both the input and output contexts by rule \tfunc, and will be substituted
for the same name. Therefore, $t$ can be typed by \tfunc after the
substitution.

\item $t = x.m$.
Substition is defined on this term such that
$\subst{x_i}{y_i}{x.m} \equiv y.m$
where $y = x_j$ if $x = y_j$ for some $y_j \in \overline{y_i}$.
Otherwise, $y = x$.

Rule \tmethc requires that $x$ exist in both $\Gamma$ and $\Gamma'$ and
therefore any substitution of x in the term will be matched with the
same substitution in the contexts. Therefore, $t$ can be typed by
\tmethc after the substitution.

\item $t = \ift{t_c}{t_t}{t_f}$. Substitution is defined on this term such
that \\
$\subst{x_i}{y_i}{(\ift{t_c}{t_t}{t_f})} \equiv 
\ift{\substxy{t_c}}{\substxy{t_t}}{\substxy{t_f}}$.
By rule \tif there exists $\Gamma_1$, $\Gamma_2$, $\Gamma_3$, $T_t$, $T_f$
such that
$\typerule{\Gamma}{t_c}{\boolt}{\Gamma_1}$ and that
$\typerule{\Gamma_1}{t_t}{T_t}{\Gamma_2}$ and that
$\typerule{\Gamma_1}{t_f}{T_f}{\Gamma_3}$ where
$\Gamma' = \Gamma_2 \sqcup \Gamma_3$ and $T = T_t \sqcup T_f$. By induction
substitution can be performed on $t_c$, $t_t$ and $t_f$ such that
$\typerule{\substxy{\Gamma}}{\substxy{t_c}}{\boolt}{\substxy{\Gamma_1}}$ and that
$\typerule{\substxy{\Gamma_1}}{\substxy{t_t}}{T_t}{\substxy{\Gamma_2}}$ and
$\typerule{\substxy{\Gamma_1}}{\substxy{t_f}}{T_f}{\substxy{\Gamma_3}}$.
By the definition of substitution on contexts, 
$\substxy{\Gamma_2} \sqcup \substxy{\Gamma_3} = \substxy{\Gamma'}$. Therefore,
by rule \tif, 
$\typerule{\substxy{\Gamma}}{\substxy{\ift{t_c}{t_t}{t_f}}}{T}{\substxy{\Gamma'}}$.
\end{itemize}
\end{proof}


\section{Existence of principal types}
\label{app:principal}

\subsection{Concatenation of effect types}
$T \gg T' \cdot U \gg U'$ is the concatenation operation for effect types. 
Effect concatenation is a partial binary operation that produces an 
effect type $V \gg V'$ such that:

\begin{itemize}
\item $V <: T$
\item $V_{mid} <: \remapapp{V}{T}{T'}$
\item $V_{mid} <: U$
\item $V' <: \remapapp{V_{mid}}{U}{U'}$
\end{itemize}

The intuition behind effect concatenation is to find a variable input and
output type for $x$ in the term {\tt f(x) ; g(x) } given 
$f : (T \gg T') \rightarrow \top$ and
$g : (U \gg U') \rightarrow \top$. The typing
$\tau = (\Gamma, \top, \Gamma')$ of term $t$ where
$\Gamma = \Gamma_f, x : V$,
$\Gamma' = \Gamma_f, x : V''$ and
$\Gamma_f = f : (T \gg T') \rightarrow, g : (U \gg U') \rightarrow \top$.
If $\tau$ exists, then $\tau$ is the principal typing for $t$, given
the assumed types of $f$ and $g$.

$T \gg T' \cdot U \gg U'$ is defined such that:

\begin{itemize}
\item The concatenation of identical effects where the input and
output types are equal is idempotent: $T \gg T \cdot T \gg T = T \gg T$.
\item Where function types are concerned, the meet of the function types
is used. Let $T = \funt{T_i}{T_i'}{T'}$, and
$U = \funt{U_i}{U_i'}{U'}$. If $V = T \sqcap U$ is defined, then
$T \gg T \cdot U \gg U = V \gg V$. Otherwise
$T \gg T \cdot U \gg U$ is undefined.
\item The concatenation of effects concerning object types is the most
interesting case.
Consider the effect types $\ot{O_1}{S_1} \gg \ot{O_1}{S_2}$ and
$\ot{O_2}{S_3} \gg \ot{O_2}{S_4}$. Each effect type defines a
deterministic finite state machine: $O_1 = (\Sigma_1, M_1, \Delta_1)$
defines the state labels and transitions, while $\overline{S_1}$ 
defines the input state set and $\overline{S_2}$ defines the output
state set. Therefore, the well-understood process of
deterministic finite state machine concatentation can be used to produce
a new finite state machine $(O_3, \overline{S_5}, \overline{S_6})$ from
the two machines $\mathcal{M}_1 = (O_1, \overline{S_1}, \overline{S_2})$ and
$\mathcal{M}_2 = (O_2, \overline{S_3}, \overline{S_4})$. The effect type
$\ot{O_3}{S_5} \gg \ot{O_3}{S_6}$ can then be extracted from this.

The function defining the concatenation operation for state machines is
not always defined, due to the return types of methods.
If $\mathcal{M}_1$ contains a transition out of an end state $m : T$
while the second contains a transition out of the initial state 
$m : U$, then the concatenation is only defined if $T \sqcap U$ is defined.
This would then be the return type of the method $m$ in the concatenated
machine, where the two methods would overlap.
\end{itemize}

\subsection{Concatenation of contexts}

Let $t$ and $t'$ be arbitrary typeable terms. If $(\Gamma_1, T, \Gamma_1')$
is a typing of $t$ and $(\Gamma_2, U, \Gamma_2')$ is a typing of $t'$, we
desire a means of deriving a typing for the term {\tt t ; t'} if one exists.
Using effect concatentation, the partial function
$\mathit{seqctx}(\Gamma_1, \Gamma_1', \Gamma_2, \Gamma_2')$ can be defined
which fufills this function, with some restrictions.

Let $\Gamma_1, \Gamma_1', \Gamma_2, \Gamma_2'$ be contexts such
that $dom(\Gamma_1) = dom(\Gamma_1')$ and $dom(\Gamma_2) = dom(\Gamma_2')$.

Let $\overline{x} = dom(\Gamma_1) - dom(\Gamma_2)$.
Let $\Gamma_x = \overline{x : \Gamma_1(x)}$.
and $\Gamma_x' = \overline{x : \Gamma_1'(x)}$.

Let $\overline{y} = dom(\Gamma_2) - dom(\Gamma_1)$.
Let $\Gamma_y = \overline{y : \Gamma_2(y)}$.
and $\Gamma_y' = \overline{y : \Gamma_2'(y)}$.

Let $\overline{z} = dom(\Gamma_1) \cap dom(\Gamma_2)$. For each
$z_i \in \overline{z}$, let $T_i \gg V_i = 
\Gamma_1(z_i) \gg \Gamma_1'(z_i) \cdot \Gamma_2(z_i) \gg \Gamma_2'(z_i)$,
which may be undefined. 

Where it is defined, let $U_i = \remapapp{T_i}{\Gamma_1(z_i)}{\Gamma_1'(z_i)}$.
By the definition of effect concatenation, we have that:

\begin{itemize}
\item $T_i <: \Gamma_1(z_i)$
\item $U_i <: \Gamma_2(z_i)$
\item $V_i <: remap(U_i, \Gamma_b(z_i) \gg \Gamma_b'(z_i))$
\end{itemize}

We define $\mathit{seqctx}$ such that
$\mathit{seqctx}(\Gamma_1, \Gamma_1', \Gamma_2, \Gamma_2') = (\Gamma, \Gamma_{mid}, \Gamma')$,
where:

\begin{itemize}
\item $\Gamma = \Gamma_x, \Gamma_y, \overline{z_i : T_i}$.
\item $\Gamma_{mid} = \Gamma_x', \Gamma_y, \overline{z_i : U_i}$.
\item $\Gamma' = \Gamma_x', \Gamma_y', \overline{z_i : V_i}$.
\end{itemize}

It follows that $\Gamma$, $\Gamma_{mid}$ and $\Gamma'$ have the following
properties:

\begin{itemize}
\item $dom(\Gamma) = dom(\Gamma') = dom(\Gamma_1) \cup dom(\Gamma_2)$
\item $\forall x \in \Gamma_1 . \Gamma(x) <: \Gamma_1(x)$
\item $\forall x \in \Gamma_1' . \Gamma_{mid}(x) <: \Gamma_1'(x)$
\item $\forall x \in \Gamma_2 . \Gamma_{mid}(x) <: \Gamma_2(x)$
\item $\forall x \in \Gamma_2' . \Gamma'(x) <: \Gamma_2'(x)$
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%% lem:principal_nofun %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% BROKEN, needs remap fixes

\subsection{Proofs \& Supporting Lemmas}

\begin{lem}
\label{lem:principal_nofun}
Principal typings exist for all terms $t$ which do not contain function calls.
\end{lem}

\begin{proof}
by induction on the structure of $t$.

\begin{itemize}
\item $t = \unitv$. 
Trivially, the typing $(\emptyset, \unitt, \emptyset)$ is principal.

\item $t = \truev$ or $t = \falsev$. 
Trivially, the typing $(\emptyset, \boolt, \emptyset)$ is principal.

\item $t = \funv{x_i}{T_i}{U_i}{t'}$. 
As $t$ is typeable, it must be the case that $t'$ is typeable also.
By induction, the term $t'$ has a principal typing
$(\Gamma, T, \Gamma')$. It follows that for each $i$, if $x_i \notin dom(\Gamma)$
then $x_i$ is not used in $t'$. Let $\overline{x_j} \subseteq \overline{x_i}$
be the set of such unused variables.
Let $\Gamma_2 = \Gamma, \overline{x_j : \top}$ and 
$\Gamma_2' = \Gamma', \overline{x_j : \top}$.
By \lemref{lem:weakening}, $(\Gamma_2, T, \Gamma_2')$ is a typing of $t'$.

If the effect $T_i \gg U_i$ is specified for parameter $x_i$ then it
must be the case that $T_i <: \Gamma_2(x_i)$ for each $i$ so that 
$t$ is typeable by rule \tfunc.
Let $\Gamma_3 = \overline{x_i : T_i'}$ such that:

\begin{itemize}
\item $T_i' = T_i$ if $T_i$ is specified
\item $T_i' = \Gamma_2(x_i)$ otherwise.
\end{itemize}

By repeated application of \lemref{lem:upgrade}, there exists a $\Gamma_3'$ and 
$T'$ such that
$(\Gamma_3,T',\Gamma_3')$ is a typing of $t'$, where $T' <: T$,
$dom(\Gamma_3') = dom(\Gamma_2')$ and 
$\forall x \in \Gamma_3' . \Gamma_3'(x) <: \Gamma_2'(x)$.

Let $U_i' = U_i$ if $U_i$ is specified or $U_i' = \Gamma_3'(x)$ otherwise.
It must be the case that $\Gamma_3'(x) <: U_i'$ for each $i$ so that
$t$ is typeable by rule \tfunc.
Let $\Gamma_4 = \overline{x_i : U_i}$.
By repeated application of rule \twiden, 
$(\Gamma_3,T',\Gamma_4)$ is a typing of $t'$.

By rule \tfundef it follows that
$\tau = (\emptyset, \funt{T_i'}{U_i'}{T'}, \emptyset)$ is a typing of $t$. 
There can be no stronger typing than this, as $T_i'$ has an upper bound
determined by either the principal typing of $t'$ or the user specified
type $T_i$. Similarly, $U_i'$ has a lower bound determined by
modification of the principal typing of $t'$ or the user specified
$U_i$. Therefore $\tau$ is the principal type of $t$.

\item $t = \left[ \overline{S_i \{ \overline{ m_{ij} = (v_{ij},S_{ij}') } \} } \right]@S$.
As $t$ is typeable, each $v_{ij}$ must be typeable also.
By induction, each $v_{ij}$ has a principal typing $(\emptyset, T_{ij}, \emptyset)$,
as values can be typed with arbitrary input contexts, and principal typings
have the smallest input context domain possible.

Trivially, $\tau = (\emptyset,\{ \overline{ S_i \{ \overline{ m_{ij} = T_{ij} \Rightarrow S_ij } \} } \}@S,\emptyset)$ is
the principal typing of $t$.

\item $t = \lett{x}{t_v}{t_b}$.

As $t$ is typeable, $t_v$ and $t_b$ must be typeable also.
By induction, $t_v$ has a principal typing $(\Gamma_v,T_v,\Gamma_v')$, and
$t_b$ has a principal typing $(\Gamma_b,T_b,\Gamma_b')$.
As $t$ is typeable, by rule \tlet it must be the case that 
$x \notin dom(\Gamma_v)$.

Let $\Gamma_b'' = \Gamma_b - \{x\}$ and
$\Gamma_b''' = \Gamma_b' - \{x\}$.

Let $(\Gamma_{in}, \Gamma_{mid}, \Gamma_{out}) = seqctx(\Gamma_v, \Gamma_v', \Gamma_b'', \Gamma_b''')$.
If this is undefined, then there exists a $y \in dom(\Gamma_v) \cap dom(\Gamma_b'')$
that cannot be assigned a type that supports the usage of $y$ in $t_v$
followed by $t_b$. In this case, $t$ itself would be untypeable. 
Therefore, $seqctx(\Gamma_v, \Gamma_v', \Gamma_b'', \Gamma_b''')$
is defined.

By \lemref{lem:upgrade} and the definition of $\mathit{seqctx}$, 
there exists a $T_v' <: T_v$ such that
$(\Gamma_{in}, T_v', \Gamma_{mid})$ is a typing of $t_v$.

If $x \in \Gamma_b$, let $T_x = \Gamma_b(x)$ and $T_x' = \Gamma_b'(x)$.
If $x \notin \Gamma_b$ (i.e. $x$ is not used in the body of the let binding), 
let $T_x = T_x' = \top$. Either directly or by \lemref{lem:weakening},
$((\Gamma_b'', x : T_x), T_b, (\Gamma_b''', x : T_x'))$ is a typing of $t'$.

In order for $t$ to be typeable, it must be the case that $T_v' <: T_x$.
Let $\Gamma_{mid}' = \Gamma_{mid}, x : T_v'$.
By \lemref{lem:upgrade}, there exists a $T_b' <: T_b$ and $T_x'' <: remap(T_v', T_x \gg T_x')$ such that
$(\Gamma_{mid}', T_b', (\Gamma_{out}, x : T_x''))$ is a typing of $t_b$.

By rule \tlet it follows that $(\Gamma_{in}, T_b', \Gamma_{out})$ is a
typing of $t$. This typing must be principal.

%%% TODO: proof of principality from construction?


\item $t = x.m$.

Let $O = \{ S \{ m : \top \Rightarrow S' \} S' \{ \} \}$.

Trivially, $\tau = (x : O@S, \top,  x : O@S')$
is a principal typing of $t$.

\item $t = t_a; t_b$.

As $t$ is typeable, it must be the case that $t_a$ and $t_b$ are typeable.
By induction, $t_a$ has a principal typing $(\Gamma_a, T_a, \Gamma_a')$ and
$t_b$ has a principal typing $(\Gamma_b, T_b, \Gamma_b')$.

Let $(\Gamma, \Gamma_{mid}, \Gamma') = \mathit{seqctx}(\Gamma_a, \Gamma_a', \Gamma_b, \Gamma_b')$.
If this is not defined, then there exists a $y \in dom(\Gamma_a) \cap dom(\Gamma_b)$
that cannot be assigned a type that supports the usage of $y$ in $t_a$
followed by the usage in $t_b$. 
In this case, $t$ itself would be untypeable. Therefore, it must be defined.

By the definition of $\mathit{seqctx}$, we have that for each
$x \in dom(\Gamma_a)$ that $\Gamma(x) <: \Gamma_a(x)$, and
that $\Gamma_{mid}(x) <: \remapapp{\Gamma(x)}{\Gamma_a(x)}{\Gamma_a'{x}}$.

%%% TODO: Prove that
It follows that $(\Gamma, T_a', \Gamma_{mid})$ is a typing of
$t_a$.


%%% TODO: prove that
It follows that $(\Gamma_{mid}, T_b', \Gamma_{mid})$ is a typing of
$t_b$.


It follows by rule \tseq that $(\Gamma_{in}, T_b', \Gamma_{out})$ is a typing
of $t$.

%%% TODO: show this is minimal.

\item $t = \ift{t_c}{t_t}{t_f}$.

As $t$ is typeable, it follows that $t_c$, $t_t$ and $t_f$ must be typeable.
By induction, $t_c$ has a principal typing $\tau_c = (\Gamma_c, T_c, \Gamma_c')$,
$t_t$ has a principal typing $\tau_t = (\Gamma_t, T_t, \Gamma_t')$ and
$t_f$ has a principal typing $\tau_f = (\Gamma_f, T_f, \Gamma_f')$.

In order for $t$ to be typeable, it must be the case that a typing
$(\Gamma_c'', \boolt, \Gamma_c''')$ exists for $t_c$. It follows that as
$\tau_c$ is a principal typing for $t_c$, that for each $x \in \Gamma_a$ that 
$\Gamma_a''(x) <: \Gamma_a(x)$ and that $\Gamma_a'(x) <: \Gamma_a'''(x)$,
with $\boolt <: T_c$.

%%% seqctx for T_c -> T_t branch

%%% seqctx for T_c -> T_f branch

%%% \sqcap of all types in respective \Gamma_{in} of each seqctx to
%%% derive overall typing.

%%% show this is principal.

\end{itemize}
\end{proof}

\begin{thm}
\label{thm:principal}
Principal typings exist for all terms $t$ which
are typeable when a type can be assumed for all variables used as functions.
\end{thm}

\begin{proof}
by induction on the structure of $t$.

\end{proof}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%% normalisation  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Context constraint normalisation}
\label{app:ctx_norm}

For the purposes of the following proofs, existential quantification of
context variables will be omitted. We shall assume that all introduced
context variables are globally fresh.

\begin{defn}[Context sub-constraint]
Given a constraint $C$, the function $ctx(C)$ returns the sub-constraint
of $C$ composed of only context constraints, i.e. those of class $\mathcal{C}$
in \figref{fig:congrammar}.
\end{defn}

\begin{defn}[Context variable definition]
A context $C$ {\it defines} context variable $\gamma$, written
$\gamma \in C$, if $C$ contains a sub-constraint $\free{\gamma}$,
$\gamma = \emptyset$ or $\gamma = \gamma', \overline{x_i : \tinf_i}$.
\end{defn}

\begin{defn}[Context root]
Given a normalised constraint $C$ where $\gamma \in C$, the 
function $root(\gamma, C)$ is defined as follows:

\begin{itemize}
\item If $\free{\gamma}$ is a sub-constraint of $C$, then $root(\gamma, C) = \gamma$.
\item If $\gamma = \emptyset$ is a sub-constraint of $C$, then $root(\gamma, C) = \gamma$.
\item If $\gamma = \gamma', \overline{x_i : \tinf_i}$ is a sub-constraint of $C$, then
$root(\gamma, C) = \gamma'$.
\end{itemize}
\end{defn}

\begin{defn}
Given a normalized constraint $C$ where $\gamma \in C$,
the {\it domain} of $\gamma$ (written $dom(\gamma, C)$) is defined as follows:

\begin{itemize}
\item If $\free{\gamma}$ is a sub-constraint of $C$, 
then $dom(\gamma, C) = \emptyset$.
\item If $\gamma = \emptyset$ is a sub-constraint of $C$,
then $dom(\gamma, C) = \emptyset$.
\item If $\gamma = \gamma', \overline{x_i : \tinf_i}$ is a sub-constraint of $C$
then $dom(\gamma, C) = \overline{x_i}$.
\end{itemize}
\end{defn}

\begin{defn}
Given two normalised context constraints $C$ and $C'$ we say that
$C'$ is {\it stronger} than $C$ (written $C \leq C'$) if:

\begin{itemize}
\item The domains of the context variables monotonically increase: 
$\forall \gamma \in C, dom(\gamma, C) \subseteq dom(\gamma, C')$
\item Root relationships do not change: 
$\forall \gamma_a, \gamma_b \in C, root(\gamma_a, C) = root(\gamma_b, C) \implies root(\gamma_a, C') = root(\gamma_b, C')$.
\item The domains of related contexts change consistently:
$\forall \gamma_a, \gamma_b \in C, root(\gamma_a, C) = root(\gamma_b, C) \cand dom(\gamma_a, C) = dom(\gamma_b, C) + \overline{x_i} \implies dom(\gamma_a, C') = dom(\gamma_b, C') + \overline{x_i}$.
\end{itemize}

$C \leq C'$ is a partial order.

\end{defn}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%% thm:ctx_norm  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{thm}[Normalisation]
\label{thm:ctx_norm}
Let $t$ be an arbitrary term. Let $C_t = ctx(\inferlhs{t})$.
Given a normalised constraint $C$ where $\gamma \in C$ and $\gamma' \notin C$,
$C \cand C_t$ is normalisable. Where an error is not generated, the normalised
output $C'$ will have the following properties:

\begin{enumerate}
\item $C \leq C'$
\item $dom(\gamma, C') = dom(\gamma', C')$.
\item $root(\gamma, C') = root(\gamma', C')$.
\end{enumerate}

\end{thm}

\begin{proof}
By induction on the structure of t.

\begin{itemize}
\item $t = unit$. It follows that 
$C_t \coloneqq \gamma' = \gamma$. 
By \lemref{lem:norm_eq}, $C \cand \gamma' = \gamma$ is normalisable.
If no error is generated, then the normalised output $C'$ has all the required 
properties.

\item $t = true$. Same as $t = unit$.

\item $t = false$. Same as $t = unit$. 

\item $t = \left[ \overline{ S_i \{ \overline{m_{ij} = (v_{ij}, S_{ij})} \} }  \right]@S$.
It follows that \\
$C_t \coloneqq 
\gamma' = \gamma \cand
\overline{\gamma_{ij} = \emptyset} \cand
\overline{\inferrule{\gamma_{ij}}{v_{ij}}{\alpha_{ij}}{\gamma_{ij}'}}.
$.

By \lemref{lem:norm_eq} the constraint $C \cand \gamma' = \gamma$ is
normalisable. If no error is generated, the normalised output $C_2$ will be such that $C \leq C_2$ with
$dom(\gamma, C_2) = dom(\gamma', C_2)$ and $root(\gamma, C_2) = root(\gamma', C_2)$.

Let $C_3 = C_2 \cand \overline{\gamma_{ij} = \emptyset}$. 
$C_3$ is normalised by definition, with $C_2 \leq C_3$.

By repeated application of the induction hypothesis, the constraint
$C_3 \cand \overline{\inferrule{\gamma_{ij}}{v_{ij}}{\alpha_{ij}}{\gamma_{ij}'}}$
is normalisable. If no error is generated, the normalised output $C_4$ will be such that $C_3 \leq C_4$. Transitively, $C \leq C_4$, and the domains and roots
of $\gamma$ and $\gamma'$ will still be such that $dom(\gamma, C_4) = dom(\gamma', C_4)$ and $root(\gamma, C_4) = root(\gamma', C_4)$.

\item $t = \lambda(\overline{x_i : T_i \gg T_i'}).t'$. 
It follows that 
$C_t \coloneqq 
\gamma' = \gamma \cand \\
\gamma_r = \emptyset \cand \gamma_{in} = \gamma_r, \overline{x_i : \alpha_i} \cand
\overline{x_i : \alpha_i' \in \gamma_{out}} \cand \\
ctx(\inferrule{\gamma_{in}}{t'}{\alpha'}{\gamma_{out}})$.

By \lemref{lem:norm_eq}, the constraint $C \cand \gamma' = \gamma$
is normalisable. If no error is generated, the normalised output $C_2$ will be such that $C \leq C_2$ with $dom(\gamma, C_2) = dom(\gamma', C_2)$ and
$root(\gamma, C_2) = root(\gamma', C_2)$.

Let $C_3$ be the constraint 
$C_2 \cand \gamma_r = \emptyset \cand \gamma_{in} = \gamma_r, \overline{x_i : \alpha_i}$.
$C_3$ is normalised by definition, with $C_2 \leq C_3$.

The constraint $C_3 \cand ctx(\inferrule{\gamma_{in}}{t'}{\alpha}{\gamma_{out}})$
is normalisable by induction. Let $C_4$ be the normalised output, where
$C_3 \leq C_4$.

Let $C_5$ be the constraint 
$C_4 \cand \overline{x_i : \alpha_i' \in \gamma_{out}}$.
This constraint is normalisable by repeated application of 
\lemref{lem:norm_usage}. If no error is generated, the normalised constraint 
$C_5$ will be produced, where $C_4 \leq C_5$.

Transitively, $C \leq C_5$. It is also the case that $C_2 \leq C_5$, therefore 
$dom(\gamma, C_5) = dom(\gamma', C_5)$ and
$root(\gamma, C_5) = root(\gamma', C_5)$.

\item $t = \lett{x}{t'}{t''}$.
It follows that \\
$C_t \coloneqq \gamma_{in} = \gamma_v, x : \alpha' \cand 
\gamma' = \gamma_{out} - \{x\} \cand \\
ctx(\inferrule{\gamma}{t'}{\alpha'}{\gamma_v}) \cand
ctx(\inferrule{\gamma_{in}}{t''}{\alpha}{\gamma_{out}})$.

By induction, the constraint 
$C \cand ctx(\inferrule{\gamma}{t'}{\alpha'}{\gamma_v})$ is normalisable.
If no error is generated, the normalised output $C_2$ will be such that
$C \leq C_2$ with $dom(\gamma, C_2) = dom(\gamma_v, C_2)$ and
$root(\gamma, C_2) = root(\gamma_v, C_2)$.

The constraint $C_2 \cand \gamma_{in} = \gamma_v, x : \alpha'$ is
normalisable by \lemref{lem:norm_ext}. If no error is generated, the
normalised output $C_3$ will be such that $C_2 \leq C_3$ with 
$dom(\gamma_{in}, C_3) = dom(\gamma_v, C_3) + \{ x \}$.

By induction, the constraint
$C_3 \cand ctx(\inferrule{\gamma_{in}}{t''}{\alpha}{\gamma_{out}})$
is normalisable. If no error is generated, the normalised output $C_4$
will be such that
$C_3 \leq C_4$ with $dom(\gamma_{in}, C_4) = dom(\gamma_{out}, C_4)$
and $root(\gamma_{in}, C_4) = root(\gamma_{out}, C_4)$.

As $x \in dom(\gamma_{in}, C_3)$, it must therefore be the case that
$x \in dom(\gamma_{in}, C_4)$, and that $x \in dom(\gamma_{out}, C_4)$.

By rule $\textsc{c\_rem}$, the constraint
$C_4 \cand \gamma' = \gamma_{out} - \{ x \}$ can be transformed
to $C_5 = C_4 \cand \gamma' = \gamma_r, \overline{x_i : \tinf_i}$, where
$\gamma_r = root(\gamma_{out}, C_4)$, and 
$\overline{x_i} = dom(\gamma_{out}, C_4)$. $C_5$ is normalised by definition,
with $C_4 \leq C_5$.

As $C_3 \leq C_5$, it can be observed that $dom(\gamma_{in}, C_5) = dom(\gamma_v, C_5) + \{x\}$ (as this relationship holds for $C_3$) and that 
$dom(\gamma_{in}, C_5) = dom(\gamma_{out}, C_5)$. Therefore, $dom(\gamma') = dom(\gamma_{out}, C_5) - \{x\} = dom(\gamma)$. Additionally, $root(\gamma, C_5) = root(\gamma', C_5)$ and transitively, $C \leq C_5$.

\item $t = t' ; t''$.
It follows that
$C_t \coloneqq 
ctx(\inferrule{\gamma}{t'}{\alpha'}{\gamma''}) \cand
ctx(\inferrule{\gamma''}{t''}{\alpha}{\gamma'})$.

By induction, the constraint 
$C \cand ctx(\inferrule{\gamma}{t'}{\alpha'}{\gamma''})$ is normalisable.
If no error is generated, the normalised output $C_2$ will be such that
$C \leq C_2$ with $dom(\gamma, C_2) = dom(\gamma'', C_2)$ and
$root(\gamma, C_2) = root(\gamma'', C_2)$.

By induction, the constraint
$C_2 \cand ctx(\inferrule{\gamma''}{t''}{\alpha'}{\gamma'})$ is normalisable.
If no error is generated, the normalised output $C_3$ will be such that
$C_2 \leq C_3$ with $dom(\gamma'', C_3) = dom(\gamma', C_3)$ and
$root(\gamma'', C_3) = root(\gamma', C_3)$.

As $C_2 \leq C_3$, it also follows that $dom(\gamma, C_3) = dom(\gamma'', C_3)$
and $root(\gamma, C_3) = root(\gamma'', C_3)$. Therefore,
$dom(\gamma, C_3) = dom(\gamma', C_3)$ and 
$root(\gamma, C_3) = root(\gamma', C_3)$. Transitively, $C \leq C_3$.

\item $t = x(\overline{x_i})$.
It follows that
$C_t \coloneqq \overline{x_i : \alpha_i \in \gamma} \cand 
x : \tinf_x \cand
\gamma' = \gamma[\overline{x_i \mapsto \tinf_i}]
$.

The constraint $C \cand x : \alpha_x \in \gamma$ is normalisable by 
\lemref{lem:norm_usage}. If no error is generated, the normalised output $C_2$ will be such that $C \leq C_2$ with $x \in dom(\gamma, C_2)$.

The constraint $C_2 \cand \overline{x_i : \alpha_i \in \gamma}$ is normalisable
by repeated application of \lemref{lem:norm_usage}. If no error is generated, the normalised output $C_3$ will be such that $C_2 \leq C_3$ with
$x_i \in dom(\gamma, C_3)$, for all $i$.

The constraint $C_3 \cand \gamma' = \gamma[\overline{x_i \mapsto \remapapp{\alpha_i}{\alpha_i'}{\alpha_i''}}]$
is normalisable by \lemref{lem:norm_rep}. If no error is generated, the
normalised output $C_4$ will be such that $C_3 \leq C_4$ with
$dom(\gamma, C_4) = dom(\gamma', C_4)$ and $root(\gamma, C_4) = root(\gamma', C_4)$. Transitively, $C \leq C_4$.

\item $t = x.m$.
It follows that
$C_t \coloneqq x : \alpha_o@\alpha_s \in \gamma \cand
\gamma' = \gamma[x \mapsto \alpha_x]
$.

The constraint $C \cand x : \alpha_o@\alpha_s \in \gamma$ is normalisable
by \lemref{lem:norm_usage}. If no error is generated, the normalised output
$C_2$ will be such that $C \leq C_2$ with $x \in dom(\gamma, C_2)$.

The constraint $C_2 \cand \gamma' = \gamma[x \mapsto \alpha_x]$ is normalisable
by \lemref{lem:norm_rep}. If no error is generated, the normalised output $C_3$ will be such that $C_2 \leq C_3$ with
$dom(\gamma', C_3) = dom(\gamma, C_3)$ and $root(\gamma', C_3) = root(\gamma, C_3)$. Transitively, $C \leq C_3$.

\item $t = \ift{t_c}{t_t}{t_f}$.
It follows that
$C_t \coloneqq
ctx(\inferrule{\gamma}{t_c}{\alpha_c}{\gamma_c}) \cand
ctx(\inferrule{\gamma_c}{t_t}{\alpha_t}{\gamma_t}) \cand
ctx(\inferrule{\gamma_c}{t_f}{\alpha_f}{\gamma_f}) \cand
\gamma' = \gamma_t \sqcup \gamma_f
$.

By induction, the constraint
$C \cand ctx(\inferrule{\gamma}{t_c}{\alpha_c}{\gamma_c})$ is normalisable.
If no error is produced, the normalised output $C_2$ will be such that
$C \leq C_2$ with $dom(\gamma, C_2) = dom(\gamma_c, C_2)$ and
$root(\gamma, C_2) = root(\gamma_c, C_2)$.

By induction, the constraint
$C_2 \cand ctx(\inferrule{\gamma_c}{t_t}{\alpha_t}{\gamma_t})$ is normalisable.
If no error is produced, the normalised output $C_3$ will be such that
$C_2 \leq C_3$ with $dom(\gamma_c, C_3) = dom(\gamma_t, C_3)$ and
$root(\gamma_c, C_3) = root(\gamma_t, C_3)$.

By induction, the constraint
$C_3 \cand ctx(\inferrule{\gamma_c}{t_f}{\alpha_f}{\gamma_f})$ is normalisable.
If no error is produced, the normalised output $C_4$ will be such that
$C_3 \leq C_4$ with $dom(\gamma_c, C_4) = dom(\gamma_f, C_4)$ and
$root(\gamma_c, C_4) = root(\gamma_f, C_4)$.

It follows that as $C \leq C_2 \leq C_3 \leq C_4$, that the domains
of $\gamma$, $\gamma_c$, $\gamma_t$ and $\gamma_f$ are all equal in $C_4$,
as are their roots.

It follows by rule $\textsc{c\_join}$ that the constraint
$C_4 \cand \gamma' = \gamma_t \sqcup \gamma_f$ can be transformed to
$C_5 = C_4 \cand \gamma' = \gamma_r, \overline{x_i : T_i} \cand \overline{T_i = T_t \veebar T_f}$ 
where $\overline{x_i} = dom(\gamma, C_4)$. Therefore $dom(\gamma, C_4) = dom(\gamma', C_4)$ and $root(\gamma, C_4) = root(\gamma', C_4)$. Trivially, $C_4 \leq C_5$ and transitively $C \leq C_5$.

\end{itemize}
\end{proof}

\begin{cor}
Given an arbitrary root term $t$, the generated constraint set for $t$,
which is defined as
$\exists \gamma, \gamma', \alpha . \free{\gamma} . \inferlhs{t}$,
is normalisable.
\end{cor}

\subsection{Supporting Lemmas}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%% lem:norm_eq  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lem}[Equality normalisation]
\label{lem:norm_eq}
Given a normalised constraint $C$ where $\gamma \in C$ and $\gamma' \notin C$, 
the constraint $C \cand \gamma' = \gamma$ is normalisable. Where an
error is not generated, the normalised output $C'$ will have the following
properties:

\begin{enumerate}
\item $dom(\gamma', C') = dom(\gamma, C')$
\item $root(\gamma', C') = root(\gamma, C')$
\item $C \leq C'$.
\item $\forall \gamma'' \in C, dom(\gamma'', C'') = dom(\gamma'', C)$
\end{enumerate}

\end{lem}
\begin{proof}
There are two cases to consider:

\begin{itemize}
\item The sub-constraint $\free{\gamma}$ or $\gamma = \emptyset$ exists
in $C$. By rule $\textsc{c\_eq\_2}$ the constraint $C \cand \gamma' = \gamma$
will be transformed to $C_2 = C \cand \gamma' = \gamma, \emptyset$, which is
normalised and has all the required properties.

\item The sub-constraint $\gamma = \gamma'', \overline{x_i : \tinf_i}$ exists
in $C$. By rule $\textsc{c\_eq}$ the constraint $C \cand \gamma' = \gamma$
will be transformed to 
$C_2 = C \cand \gamma' = \gamma'', \overline{x_i : \tinf_i}$,
which is normalised and has all the required properties.
\end{itemize}
\end{proof}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%% lem:norm_ext  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lem}[Extension normalisation]
\label{lem:norm_ext}
Given a normalised constraint $C$ where $\gamma \in C$ and $\gamma' \notin C$, 
the constraint $C' = C \cand \gamma' = \gamma, \overline{x_i : \tinf_i}$
is normalisable. When an error is not generated, the normalised output
$C''$ will have the following properties:

\begin{enumerate}
\item $dom(\gamma', C'') = dom(\gamma, C'') + \overline{x_i}$
\item $root(\gamma', C'') = root(\gamma, C'')$
\item $C \leq C''$.
\item $\forall \gamma'' \in C, dom(\gamma'', C'') = dom(\gamma'', C)$
\end{enumerate}

\end{lem}
\begin{proof}
There are two cases to consider:

\begin{enumerate}
\item The sub-constraint $\free{\gamma}$ or $\gamma = \emptyset$ exists in $C$.
The constraint $C'$ is therefore already normalised, meaning $C'' = C'$.
$C''$ has all the required properties.

\item The sub-constraint $\gamma = \gamma_r, \overline{x_j : \tinf_j}$ exists
in $C$, along with either $\free{\gamma_r}$ or $\gamma_r = \emptyset$ (as
$C$ is normalised).

If $\overline{x_i}$ and $\overline{x_j}$ are disjoint, then by rule
$\textsc{c\_ext}$ the constraint $C'$ can be transformed to
$C'' = C \cand \gamma' = \gamma_r, \overline{x_i : \tinf_i}, \overline{x_j : \tinf_j}$.
$C''$ is therefore normalised, with all the required properties.

If $\overline{x_i} \cap \overline{x_j} \neq \emptyset$, then by rule
$\textsc{c\_ext\_2}$ a $\mathbf{bound}\:x$ error will be generated, for
some $x$.
\end{enumerate}
\end{proof}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%% lem:norm_rep %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{lem}[Replacement normalisation]
\label{lem:norm_rep}
Given a normalised constraint $C$ where $\gamma \in C$ and $\gamma' \notin C$,
the constraint $C' = C \cand \gamma' = \gamma[x \mapsto \tinf]$ is normalisable. When
an error is not generated, the normalised output $C''$ will have the
following properties:

\begin{enumerate}
\item $dom(\gamma', C'') = dom(\gamma, C'')$
\item $root(\gamma', C'') = root(\gamma, C'')$
\item $C \leq C''$.
\end{enumerate}

\end{lem}
\begin{proof}

There are three cases to consider:

\begin{enumerate}

\item The sub-constraint $\free{\gamma}$ or $\gamma = \emptyset$ exists in
$C$. By rule $\textsc{c\_rep\_3}$, the constraint $C'$ can be transformed
to 
$C_2 = C \cand \gamma' = \gamma[x \mapsto \tinf] \cand x : \alpha \in \gamma$.

By \lemref{lem:norm_usage}, the constraint $C \cand x : \alpha \in \gamma$ is 
normalisable. If no
error is generated, the normalised constraint $C_3$ will be produced such
that $C \leq C_3$ and $x \in dom(\gamma, C_3)$. Therefore, by the 
reasoning of case 3 below, $C_3 \cand \gamma' = \gamma[x \mapsto \tinf]$ is 
normalisable. If no error is generated, the normalised constraint $C''$ will 
be generated with all the required properties.

\item The sub-constraint $\gamma = \gamma'', \overline{x_i : \tinf_i}$ exists
in $C$, where $x \notin \overline{x_i}$.

By rule $\textsc{c\_rep\_2}$, the
constraint $C'$ can be transformed to $C_2 = C' \cand x : \alpha \in \gamma''$.
Let $C_3 = C \cand x : \alpha \in \gamma''$. It follows that
$C_2$ is equivalent to $C_3 \cand \gamma' = \gamma[x \mapsto \tinf]$. 
By \lemref{lem:norm_usage}, $C_3$ is normalisable. If no
error is generated, the normalised constraint $C_4$ will be produced such that
$C \leq C_4$, and $x \in dom(\gamma'', C_4)$.

The constraint $C_4 \cand \gamma' = \gamma[x \mapsto \tinf]$ is normalisable
by the reasoning of case 3 below. 
If no error occurs, normalised constraint $C''$ will be produced satisfying
properties 1 and 2 and with $C_4 \leq C''$. Transitively, $C \leq C''$.

\item The sub-constraint 
$\gamma = \gamma'', \overline{x_i : \tinf_i}, x : \tinf_x$
exists in $C$. It follows by rule $\textsc{c\_rep}$ that constraint $C'$ can 
be transformed to 
$C'' = C \cand \gamma' = \gamma'', \overline{x_i : \tinf_i}, x : \tinf$, 
which is normalised and has all the required properties.

\end{enumerate}

\end{proof}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%% lem:norm_usage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{lem}[Usage normalisation]
\label{lem:norm_usage}
Given a normalised constraint $C$ where $\gamma \in C$, the constraint 
$C \cand x : \tinf \in \gamma$ is normalisable. When an error is not generated, 
the constraint $C'$ will be generated such that $C \leq C'$ and
$x \in dom(\gamma, C')$.
\end{lem}
\begin{proof}

There are three cases to consider:

\begin{enumerate}
\item $C = C_2 \cand \free{\gamma}$.

By rule $\textsc{c\_var\_1}$, the constraint
$\free{\gamma} \cand x : \tinf \in \gamma$ can be transformed to 
$C_3 = \free{\gamma_r} \cand \gamma = \gamma_r, x : \tinf$ where
$\gamma_r$ is a fresh context variable.

It remains to show that $C_4 = C_2 \cand C_3$ is normalisable.

Let $\overline{\gamma_i}$ be the set of context variables defined in
$C_2$ that have $\gamma$ as their root: for all $i$, $\gamma_i = \gamma, \overline{x_{ij}}$ is
a sub-constraint of $C_2$ (as it was previously normalised).

\begin{itemize}
\item If $\overline{\gamma_i}$ is empty, then $C_4$ is normalised.
It can be directly observed that $x \in dom(\gamma, C_4)$ and that
$C \leq C_4$.

\item If $\overline{\gamma_i}$ is not empty, then
$C_2 = C_5 \cand \overline{\gamma_i = \gamma, \overline{x_{ij}}}$.

If $x \in \overline{x_{ij}}$ for some $i$, then by rule $\textsc{c\_ext\_2}$
the error $\mathbf{bound}\:x$ will be generated.

Otherwise, by repeated application of rule $\textsc{c\_ext}$ the constraint
$C_4$ can be transformed to $C_6 = C_3 \cand C_5 \cand \overline{\gamma_i = \gamma, \overline{x_{ij}}, x : \tinf}$. For every $\gamma' \in C$, 
the following predicates hold:
\begin{itemize}
\item $root(\gamma', C) = \gamma \implies root(\gamma', C_6) = \gamma_r \cand dom(\gamma', C_6) = dom(\gamma', C_6) + \{x\}$
\item $root(\gamma', C) \neq \gamma \implies root(\gamma', C_6) = root(\gamma', C) \cand dom(\gamma', C_6) = dom(\gamma', C)$
\end{itemize}

Therefore, $C \leq C_6$, and $x \in dom(\gamma, C_6)$.
\end{itemize}

\item $C = C_2 \cand \gamma = \emptyset$, where $C_2$ is normalised.

By rule $\textsc{c\_var\_2}$, $\exists \gamma . C \cand x : \tinf \in \gamma$
will be transformed to $\mathbf{unbound}\:x$.

\item $C = C_2 \cand \gamma = \gamma_r, \overline{x_i : \tinf_i}$, where 
$C_2$ is normalised.

If $x = x_i$ for some $i$, then by rule $\textsc{tvar}$ the constraint
$C \cand x : \tinf \in \gamma$ will be transformed to $C' = C \cand \tinf_i <: \tinf$. As
the type constraint is irrelevant to normalisation, the tranformed constraint
is normalised, and $C \leq C'$. Trivially, $x \in dom(\gamma, C')$.

If $x \notin \overline{x_i}$, then by rule $\textsc{c\_var\_3}$ the
constraint $C \cand x : \tinf \in \gamma$ will be transformed to
$C \cand \overline{x_i : \tinf_i} \in \gamma_r$. As
$\gamma_r$ must be defined in $C$ by a constraint $\free{\gamma_r}$ or
$\gamma_r = \emptyset$, the reasoning of parts 1 and 2 above can be applied.
Where an error is not generated, the normalised constraint $C'$ will be
generated such that $C \leq C'$ and $x \in dom(\gamma, C')$.

\end{enumerate}
\end{proof}

\bibliographystyle{abbrvnat}
\bibliography{refs}

% The bibliography should be embedded for final submission.

%\begin{thebibliography}{}
%\softraggedright

%\bibitem[Smith et~al.(2009)Smith, Jones]{smith02}
%P. Q. Smith, and X. Y. Jones. ...reference text...

%\end{thebibliography}

\end{document}



%--------------------------------------
% abandoned stuff
%--------------------------------------

% \begin{thm}
% A closed term $t$ which is typeable always has a principal typing.
% \end{thm}

% \begin{proof}
% Let $t$ be an arbitrary closed term. $t$ must therefore be contain a
% $\lett{x_i}{t_i}{t_i'}$ sub-term for every variable that is used within
% it. We may therefore assume the existence of a type for
% any variable used by a given subterm $t'$.

% We shall prove by induction on the structure of such closed terms $t'$.
% For each $t'$, we will assume the existence of $\Gamma$, an input context
% which contains all necessary


% \begin{itemize}
% \item $t = \unitv$. The typing $(\emptyset, \unitt, \emptyset)$ is principal.

% \item $t = \truev$ or $t = \falsev$. The typing $(\emptyset, \boolt, \emptyset)$ is principal.

% \item $t = \funv{x_i}{T_i}{U_i}{t'}$. By induction, the term $t'$ has a principal typing
% $(\Gamma, T, \Gamma')$. It follows that for each $i$, if $x_i \notin dom(\Gamma)$
% then $x_i$ is not used in $t'$. Let $\overline{x_j} \subseteq \overline{x_i}$
% be the set of such unused variables.
% Let $\Gamma_2 = \Gamma, \overline{x_j : \top}$ and 
% $\Gamma_2' = \Gamma', \overline{x_j : \top}$. It is therefore the case
% that $dom(\Gamma_2) = dom(\Gamma_2') = \overline{x_i}$.
% By \lemref{lem:weakening}, $(\Gamma_2, T, \Gamma')$ is a typing of $t'$.
% As $t$ is typeable, it follows that for each $i$ that if the effect type
% $T_i \gg U_i$ is declared, that $\Gamma_2(x) <: T_i$ and that 
% $U_i <: \Gamma_2'(x)$. 
% Let $T_i' = T_i$ if $T_i$ is declared, or $T_i' = \Gamma_2(x_i)$ otherwise.
% Let $U_i' = _Ui$ if $U_i$ is declared, or $U_i' = \Gamma_2'(x_i)$ otherwise.

% By rule $\tfundef$ it follows that
% $\tau = (\emptyset, \funt{T_i'}{U_i'}{T}, \emptyset)$ is a typing of $t$. Further,
% there can be no stronger typing than this, as for each $i$ the type 
% $U_i'$ is either bounded by the user defined $U_i$, the principal variable 
% output type of $x_i$ in $t'$, or the assigned type $\top$ which is the greatest 
% element of the type lattice. Therefore, $\tau$ is the principal type of $t$.

% \item $t = \left[ \overline{S_i \{ \overline{ m_{ij} = (v_{ij},S_{ij}') } \} }]@S$.

% \item $t = \lett{x}{t_v}{t_b}$.

% \item $t = \lett{x}{t_v}{x.m}$.

% \item $t = x(\overline{x_i})$.


% \item $t = t'; t''$.

% \item $t = \ift{t_c}{t_t}{t_f}$.


% \end{itemize}
% \end{proof}